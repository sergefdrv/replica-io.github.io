<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://replica-io.dev/blog</id>
    <title>Replica_IO Blog</title>
    <updated>2025-05-30T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://replica-io.dev/blog"/>
    <subtitle>Replica_IO Blog</subtitle>
    <icon>https://replica-io.dev/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[A Sketch of Reversible Deterministic Concurrency for Distributed Protocols]]></title>
        <id>https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols</id>
        <link href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols"/>
        <updated>2025-05-30T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[A post sharing first result of elaborating the idea of reversible deterministic concurrency]]></summary>
        <content type="html"><![CDATA[<p>This post presents preliminary results of elaborating the idea that was <a href="https://github.com/orgs/replica-io/discussions/49#discussioncomment-12436415" target="_blank" rel="noopener noreferrer">introduced on project's GitHub</a> and which can be referred to as <em>reversible deterministic concurrency</em>. We try to make those ideas a little more concrete and apply them to modelling some well-known distributed protocols.</p>
<p>Designing, verifying, correctly implementing and later improving core mechanisms of complex distributed, decentralized systems, such as Byzantine fault tolerant consensus, is notoriously difficult and error-prone. One of the biggest challenges here is dealing with the inherently concurrent nature of distributed systems. So there is an underlying problem of structuring the inherently concurrent logic of distributed protocols that we don’t really know how to solve in a simple, flexible, and reliable way. Embarrassingly often, we approach this rather awkwardly and unsurprisingly end up with awfully complicated, obscure, and fragile code.</p>
<p><a href="https://github.com/replica-io/replica-io/issues/47" target="_blank" rel="noopener noreferrer">Considering what modelling approach to initially adopt in the Replica_IO framework</a>, an approach that would allow <em>both specifying and implementing</em> complex distributed protocols in a <em>natural</em> way, I decided to challenge the status quo and try to rethink the conventional approaches to modeling distributed systems and the ways of expressing distributed protocols. So came up the idea of reversible deterministic concurrency. The idea was inspired by a number of <a href="https://github.com/replica-io/replica-io/issues/7" target="_blank" rel="noopener noreferrer">explored models of computation and programming models</a>, as well as some principles from information theory, modern physics, reversible and quantum computing, such as conservation of information.</p>
<p>The long-term goal is to develop this idea further into an approach for <em>specifying</em> core mechanisms of concurrent, distributed systems, <em>implementing</em> them in Rust code, as well as <em>verifying</em> their correctness. The approach will be used as the foundation for the Replica_IO framework. Following this approach, it should be safe and easy to express concurrency and communication within the framework in a structured and composable way.</p>
<p>In order to get some intuition about the idea, we'll begin by discussing some basic principles behind it. Then we'll try modelling some well-known distributed protocols following those principles, namely the Bracha's reliable broadcast and the Tendermint consensus protocols.</p>
<p>Please bear in mind that this write-up is an early sketch and that many details of the approach presented here, including terminology, will likely undergo significant changes in the future.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="approach">Approach<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#approach" class="hash-link" aria-label="Direct link to Approach" title="Direct link to Approach">​</a></h2>
<p>We conceptually think of concurrent systems as consisting of <em>deterministic</em> components that can be connected with each other and interact <em>concurrently</em>. The only means of interaction with the components are through their <em>inputs</em> and <em>outputs</em>. Each input and output can convey a certain type of data, and they are typed accordingly. Inputs and outputs matching in type can be connected <em>pairwise</em>, so that data can flow through the connection. Connecting inputs and outputs of different components enables data flow between those components.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="base-and-composite-components-extrinsic-inputs-and-outputs">Base and composite components, extrinsic inputs and outputs<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#base-and-composite-components-extrinsic-inputs-and-outputs" class="hash-link" aria-label="Direct link to Base and composite components, extrinsic inputs and outputs" title="Direct link to Base and composite components, extrinsic inputs and outputs">​</a></h3>
<p>Components can be <em>composite</em>, i.e. consist of lower-level sub-components connected together. The remaining unconnected inputs and outputs become the inputs and outputs of the composite component. The process of decomposition bottoms out at <em>base components</em> that are considered primitive and not decomposed further. Apart from base components, there can be <em>extrinsic inputs and outputs</em> for exchanging information with the environment. The extrinsic inputs and outputs can represent interfaces for interacting with entities that are considered external to the modeled system, or they can be <em>sources</em> of auxiliary data items and <em>sinks</em> to dispose of excessive data.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="input-output-pairs-interaction-lines-and-two-kinds-of-interaction">Input-output pairs, interaction lines, and two kinds of interaction<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#input-output-pairs-interaction-lines-and-two-kinds-of-interaction" class="hash-link" aria-label="Direct link to Input-output pairs, interaction lines, and two kinds of interaction" title="Direct link to Input-output pairs, interaction lines, and two kinds of interaction">​</a></h3>
<p>Inputs and outputs can only appear in complementary pairs. This applies to inputs and outputs of base components, and therefore of composite components, as well as to extrinsic inputs and outputs. Moreover, in a complete system, every input must be connected to exactly one output matching in type. So the input-output pairs connected one to another form a kind of chains or <em>interaction lines</em>. Data items flowing along different interaction lines can interact with each other by redistributing the information contained within those data items when they arrive at the same base component. So there are <em>two kinds of interaction</em> within the system: passing data items from one component to another along interaction lines and exchange of information between data items on different interaction lines within base components.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="determinism-and-reversibility">Determinism and reversibility<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#determinism-and-reversibility" class="hash-link" aria-label="Direct link to Determinism and reversibility" title="Direct link to Determinism and reversibility">​</a></h3>
<p>All components are conceptually <em>deterministic</em>: provided all the component's assumptions hold true, the output values must be completely determined by the input values and nothing else. Although the availability of output values can depend both on the availability of the input values and on the input values themselves, neither the output values nor their availability may per se depend on the relative order in which the input values become available. (It is worth noting here that this determinism is only conceptual: later we'll see how some input values may be left unspecified and, in normal operation, get chosen on spot, possibly depending on the availability and values of other inputs.) Moreover, the components must also be <em>reversible</em>, so that the original input values can always be recovered from the resulting output values.</p>
<p>One can view the determinism and reversibility requirements as a consequence of making all information flow within the system explicit. If all information that is used to determine the output values is contained in the input values then the inputs uniquely determine the outputs and the computation is deterministic. Similarly, if the output values collectively contain all the information that was contained in the original input values then the inputs can be recovered from the outputs and the computation is reversible. Determinism and reversibility are dual to each other: if a computation carried out in one direction is reversible then the same computation carried out in the opposite direction is deterministic.</p>
<p>Requiring that components are conceptually deterministic we make non-determinism explicit, structurally evident rather than emergent or accidental, while treating concurrency implicitly as emerging naturally from data availability and the system’s structure rather than from control flow. This should improve modularity and facilitate <em>compositional reasoning</em>. Together with the reversibility requirement this ensures that there is no hidden data flow, enables backward reasoning, backtracking mechanisms, <em>reverse debugging</em> and would facilitate <em>management of resources</em>, such as memory.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="simple-components">Simple components<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#simple-components" class="hash-link" aria-label="Direct link to Simple components" title="Direct link to Simple components">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sum">Sum<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#sum" class="hash-link" aria-label="Direct link to Sum" title="Direct link to Sum">​</a></h4>
<p>We can represent components graphically. For example, the following figure depicts a component that simply adds one integer value to another:</p>
<p><img decoding="async" loading="lazy" src="data:image/png;base64,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" width="169" height="72" class="img_ev3q"></p>
<p>The component is represented by a rectangle divided into horizontal sections, one section for each input-output pair, i.e. interaction line. The component is labeled above by its name, <code>Sum</code>; its interaction lines are labeled as <code>x: Int</code> and <code>y: Int</code> , where <code>x</code> and <code>y</code> denote the names of the interaction lines and <code>Int</code> is the type of data items conveyed by them. The inputs are on the left side of the component whereas the outputs are on the right side. The component takes two integers as input values, denoted as <code>a</code> and <code>b</code>, along lines <code>x</code> and <code>y</code> and returns two integers as output values; the first input value goes through unchanged, whereas the second one becomes the sum of the two input values. The first input is required to determine both outputs, and the second input is required to determine the second output. Since this component has just two interaction lines, one of which leaves the value unchanged, we can alternatively depict it as follows:</p>
<p><img decoding="async" loading="lazy" src="data:image/png;base64,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" width="145" height="72" class="img_ev3q"></p>
<p>It is easy to see that this component is deterministic, i.e. the output values are completely determined by the input values, no matter in which order the inputs become available. It is also not hard to see that this component is reversible, i.e. the original input values can always be recovered from the resulting output values. We can depict the inverse of the component as follows:</p>
<p><img decoding="async" loading="lazy" src="data:image/png;base64,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" width="152" height="72" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="generalized-controlled-swap">Generalized controlled swap<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#generalized-controlled-swap" class="hash-link" aria-label="Direct link to Generalized controlled swap" title="Direct link to Generalized controlled swap">​</a></h4>
<p>Let's consider another example. The following component represents a kind of generalized controlled swap operation<sup><a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#user-content-fn-fredkin-gate-91b34d" id="user-content-fnref-fredkin-gate-91b34d" data-footnote-ref="true" aria-describedby="footnote-label">1</a></sup>:</p>
<p><img decoding="async" loading="lazy" src="data:image/png;base64,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" width="231" height="95" class="img_ev3q"></p>
<p>or depicted alternatively:</p>
<p><img decoding="async" loading="lazy" src="data:image/png;base64,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" width="184" height="94" class="img_ev3q"></p>
<p>It has three interaction lines: one control line, <code>c</code>, and two target lines, <code>t1</code> and <code>t2</code>. The value of the control line goes through unchanged, but it determines the output values of the target lines: If the control value is true then the values of the target lines get swapped, otherwise they simply go through unchanged. The controlled swap component is an inverse of itself.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="concurrency-of-interaction-lines">Concurrency of interaction lines<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#concurrency-of-interaction-lines" class="hash-link" aria-label="Direct link to Concurrency of interaction lines" title="Direct link to Concurrency of interaction lines">​</a></h3>
<p>Interaction lines are highly <em>concurrent</em>: an output value becomes available as soon as it can be obtained from the input values that are available for the interaction. For example, in the <code>CSwap</code> component, once the value on the control line is available, each of the target outputs remains dependent only on one of the target inputs and becomes available as soon as that input value is available, concurrently and independently of each other.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="demand-driven-nature-of-interactions">Demand-driven nature of interactions<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#demand-driven-nature-of-interactions" class="hash-link" aria-label="Direct link to Demand-driven nature of interactions" title="Direct link to Demand-driven nature of interactions">​</a></h3>
<p>Interactions are <em>demand-driven</em>: certain extrinsic inputs and some inputs of base components may demand a value from the connected output, and this demand propagates further along the inputs required to determine the demanded output value until it eventually reaches available values and triggers the interactions required to satisfy the demand. Sinks are never demanding, but they will consume the value when it becomes available.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="unspecified-values">Unspecified values<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#unspecified-values" class="hash-link" aria-label="Direct link to Unspecified values" title="Direct link to Unspecified values">​</a></h3>
<p>Certain inputs of base components may be connected to special sources of <em>unspecified</em> values. Those unspecified values are not real; they are just placeholders that stand for concrete values. During normal operation, the component will choose appropriate concrete values for such unspecified values and act as if they were guessed correctly and provided by the environment. When debugging the system or during verification, the sources of unspecified values can be forced to provide specific values; in that case, the component has no choice but to take the forced value as is. One can think of an unspecified value as a "superposition" of all possible values of the corresponding type that will "collapse" to a concrete value when going through the base component.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="the-def-component">The <code>Def</code> component<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#the-def-component" class="hash-link" aria-label="Direct link to the-def-component" title="Direct link to the-def-component">​</a></h4>
<p>The following component is meant to be used with such sources of unspecified values:</p>
<p><img decoding="async" loading="lazy" src="data:image/png;base64,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" width="134" height="72" class="img_ev3q"></p>
<p>Both interaction lines of this component conceptually go through unchanged; however, if the value of the second input is unspecified, as denoted in the picture by the special source labeled with <code>?</code>, then the component chooses it to be equal to the value of the first input. This is effectively a way to copy the value of the first input in normal operation, but the second line can be forced to an arbitrary value, e.g. to model a Byzantine failure during verification. To avoid cluttering, we will often abbreviate the <code>Def</code> component in diagrams as follows:</p>
<p><img decoding="async" loading="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHkAAABHCAMAAAAUVBimAAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAH1UExURf///+Xl5XZ2di8vLzIyMnx8fOzs7P/y8ohiYi4mJhINDQgIDScoPn+EtvT5/9jY2BgYGAAAACIiIvrX11tJSSUfHwwJCQwMFDY3U6Kq1/3///3q6WBERGJkcoOEh4eFhXBdXRcLC215yD8/P1ZWVvjExD09Tm1veoeHh4SAgF9GRgkJHqa27/r396hpaSMjcev5/7m5uaqqqpycnAEBAQUFBaampsDAwPfv7Ww1NVFcsfLc3IlwcDktLREMDBMTWuT3/ywsLEJCQt/Cwm9bWywiIgsHBz5Gmvj9//HKyjIXFxMTL2pvg52ep7S0tY5fXxMTWOP3/6WlpQkJCRQUFKmpqdGbmxIICCUnSnt+j6SlrbO1s2I1NT1FmP/+/JtbWxUVS87d+cKAgHR0dIqKiv/08FwoKDU6he31///7+YRHR//693Q5OTxDl/r6+l1dXQICAm5ubv7+/v3d3TgVFXSC0v/8+olLSyIibef0//Xf32c8PBISWNfX13h4eD09PbGxsUocHE9ZrPr+/+TAwDocHNuhoQ4HBzA0VnN0c2pbWx8REQsLC6urqwQEEEhOZ11JSQ4JCgoJCf/9/L2RkS0cHAcHDTAxT5uiyrJ6ev7w8JNqahoPDwsLF0VHa7bCv4BFRXJycry8vLS0tDY2Nvz8/LKyshQUWHcAAAABYktHRACIBR1IAAAAB3RJTUUH6QUWDjYdoIm3fwAAAZpJREFUaN7t2FVTQmEQgOHFbj22YHeiInY3drdiYHd3d2F39+/0yGEGYbzgO+IZL/a9YWBmv2eWywXAMOy/xNPTNzA0+tUTxiamZuYWllZkU9Y2FJ0tj2zKzt7B0cnZhc98E7i6uXt4ennzid7woRT5ksl+/gGBQcEhod9+ChOGRwBEirQtSszI0TFaj4hilVZcfIJyy8Sk5BQxlZoGkE79ZRm0lZmVnSOmciUKOC+/oLCouKS0jGTn8grmtcoqop2ra2rr6hsamxSytLmllf5o+5IJkjFyO9FQR2dXN0BPLyP39Q9IWMiDQ7Q7PDJKNDQ2PgEqeXJqegZgdm6eTAZYWFxaJhwRrKyuAaxvMDJsbm3v7O7tE8sgp+SEE1LhwaHs6PhEKZ+enV9cXl0T/tusZLi5vbt/eHxSyqxjIesolFFGGWWUUUYZZZRRRhlllFFGGWWUWcvqV2Yu5R+uzBzJilRXZvbys/aHXroX0Lgys+6V8L79pnFlZt/7B9HK9M7qV2YuU78yc5nGlZnDNK7MXKajKzOG/ec+AVBwyaHjwrcFAAAAAElFTkSuQmCC" width="121" height="71" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="cswap-with-unspecified-control"><code>CSwap</code> with unspecified control<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#cswap-with-unspecified-control" class="hash-link" aria-label="Direct link to cswap-with-unspecified-control" title="Direct link to cswap-with-unspecified-control">​</a></h4>
<p>The control line of the controlled swap component can also be left unspecified, e.g. as follows:</p>
<p><img decoding="async" loading="lazy" src="data:image/png;base64,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" width="119" height="95" class="img_ev3q"></p>
<p>or in an abbreviated form:</p>
<p><img decoding="async" loading="lazy" src="data:image/png;base64,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" width="101" height="94" class="img_ev3q"></p>
<p>In the diagram above, the control line is connected to a source of unspecified values, and the second target output is connected to a sink (which is never demanding). When there is a demand for the first target output value, <code>w</code>, both of the target inputs will be demanded, and the demand for <code>w</code> will be satisfied by taking either <code>u</code> or <code>v</code>, whichever becomes available earlier, and the value of the control line will be chosen accordingly. If both target inputs are available when the target output is demanded then the value of the control line is chosen to be false, i.e. the component is biased towards passing the values of target lines through without swapping them.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="synchronization">Synchronization<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#synchronization" class="hash-link" aria-label="Direct link to Synchronization" title="Direct link to Synchronization">​</a></h3>
<p>In some cases, we need to make sure that a certain value only becomes available if some other value also becomes available, without changing the values themselves. This can be achieved with the following synchronization primitive:</p>
<p><img decoding="async" loading="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGEAAAA1CAMAAABmx3VwAAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAGkUExURf////f39+7u7oyMjAAAAPjBwRMKE6a2+Pzi4j8YGHmH1+vr66qqql1dXcPDw8zMzBMKEqW1+fjExBcKCpuq9fvW1i8SEmZyw/3////7+8aXlxkLC//6+IVISAYGF1BWaG1paUItLQwNDgsGBvjg4HNQUBMMDBQUJ2JmkcDIwD4XF/zk5EYcHFNesfz///3t61QkJFlktsGAgAsLNsXX+8+Ojg0NO8rc/P/9/aNjYxYWV93v/emurg0LIbDB9/rR0SkQEHOA0f/693c8PD5FmPb8/++5uRMKDpSj6v/+/JtbWygoee35///7+YNGRigpee77//nMzCIPD5Oi6v/z8WMuLkFJnPj9/0IaGnWC09ydnQkJI7PE+L58fBgYWd7v/8B+fg4OQs/h/N2eng4OO/zj40QbG19rv//08mUvL/nQ0CgQEICO3P37+YlLS6FhYRwcZOT0/fK9vRYOIYFFRTI1h9PQyjEVFe63txIKFZ6v4qtra9qbmwoKKk9PTGItLThEUUIeHkMbGwEBAb99fQIBAQwMO6BgYAYGIK/A9/nPzyYPD/FAhqIAAAABYktHRACIBR1IAAAAB3RJTUUH6QUWDjYdoIm3fwAAAVJJREFUWMNjYBhhgJEJBBhpaAMzCwgwj9owasMwtoGVjR1IcnByUc8GNCOHmQ3cPHgBL9gGXh4CgAmPDXws1AD8GDYICFLdDwgjQUBIWITa8YBmpKiYuASDpJQ0FW1AM1JGVk5eQVFJmYo2oBupoqqmrqGpRUUbiDeSbBvIBaM2jNowasOoDUPVBm0dXT0gpW9gqAfmGxmbgChTM3Nq2WBhaWUNpGxs7SB8ewdHIOnk7OJKtVByc/dgYPD08vaBcH39/AMYGAKDgqnXEggJDQtn4IiIhNkYFR3DwBAbF0+91gxDQmISQ3IKPNhT09IlMjJBsUItPzBkZefk5iGC3SK/oLCo2I56aQkY8iWlZeXBCH5FZVU1LFaoYwNDTW0dKNhhIKS+oTGSCG0k2JDa1AzNDBDQ0tpGMDOQZoNne0cnMr+rm3BmIM0GMsGoDSPFhhELAGGQRIPIP9pUAAAAAElFTkSuQmCC" width="97" height="53" class="img_ev3q"></p>
<p>Values <code>u</code> and <code>v</code> go through the bar unchanged, but only once they both become available. Thus values <code>u</code> and <code>v</code> on the right side mean something more than those on the left side: a value becoming available on any line on the right side implies the existence and availability of some value on the other line as well.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="signals">Signals<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#signals" class="hash-link" aria-label="Direct link to Signals" title="Direct link to Signals">​</a></h3>
<p>For similar reasons, it may also be useful to have a kind of <em>signalling</em> interaction lines of unit type, which convey data items that can take only a single possible value. Such signal values themselves have no meaning other than their existence, i.e. availability. Signalling lines work naturally with synchronization bars:</p>
<p><img decoding="async" loading="lazy" src="data:image/png;base64,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" width="215" height="101" class="img_ev3q"></p>
<p>or in an abbreviated form:</p>
<p><img decoding="async" loading="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANUAAABNCAMAAAAGq9GfAAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAIHUExURf////f39+7u7oyMjAAAAPjBwRMKE6a2+Pzi4j8YGHmH1//9+oxOTjU6jPT8/7p4eBUVXOX3/7Kysqqqql1dXdDQ0BkZGXJychMKEqW1+TQ5i/jExBcKCpuq9f/8+5BRUSwugPD8//vW1i8SEmZyw/3////7+8aXlxkLC////qtoaBERSdPk/PTf32k9PRQUXP/6+IVISAYGF1BWaG1paUItLQwNDgsGBuy4uBgJCSQmR2lra2JTUxkPDw4ODvjg4HNQUBMMDBQUJ2JmkcDIwD4XF//9/cWamjQiIggIDjIzU6Kqz650dNHR0ZmZmdnZ2e+5uRQJC42c5vXExBwNDpOi6v/7+YRHRyQkc+v4/5JTUygoee35///08mQvLz1Dlfb8/7V0dBgYWd7v/9ydnQgIHq2+9v3d3ToXF3WC08F/fwwMPMvd/P/x71wpKVlktvz///zj40UcHFlkt9aWlg0NO8rc/MjIyLq6uvnQ0CgQEO62thEMIbDB96JiYhkZXeHx/4BERD5FmFlZWTExMYNFRS0vgaRjY++4uBMKEZqq7vrR0SkSEtucnAoKKbnL+v3n50sfH//z8WItLUdQo/j9+caFhUQbG2Vywt2kpA8PO799fcjeyG01NaFgYBsbS1A6OvnPzycQEEtRSxkPIRIHBwMDDoFERP/z8GEtLRcXWdqbmwYEBAexs00AAAABYktHRACIBR1IAAAAB3RJTUUH6QUWDjYeOYDmxQAAAhZJREFUeNrt2NdTE1EUwOEDRMBYKAlgRRACRIo0CyKiAqGGICUiRaJUu0gnKE26inRBuoKC/pHshndzx7nLyd2c38PuS2bOfrP3ZncWgFJlHp5yHtiXwTkvjZwX9mWQilSqilTiRCrsjnn7SEff41p+qhMnT52WTn7+AaRSTBWo+1d6h0qvc1KQq6mCNRwKcTWViu7VmbPAfV+dw1adv3CRtyr0Ulg4supyRKQBoqJjOKqMV2LjAOITruKpEpOSU1KvXb/BUQU3026l3864g6iCzLv37mdl5/BUmXLz8gsKixBXIHsivTGRilSiRCp+mYvlzCpTKT2VVOJMJZU4U0klzlRSiTNVzSqn35g4pz8SFU50r/5Hpc59RSoRppJKnKmkEmcqqcSZqk6VxfEGY1GZCidSiROpxIlU4uTWqpIHpfKprLwC7UqtDysfSafQquoaXqrax3U2AOOTp/VoKmhobJKOzS3PnP+UdQU+f/ES4NXrN2/xVK3v2gwA7R2dAF1M35icfNnqBujp1QLY+97jocD0oX8ArINDNoBhHp8LP0qremQ03DTGsKQVbHxiEqY+yTub172Cz1+mv84wLGkFm52bX1hk2tnM/+ytS9+WVzpRVfA9dnWNaWczq0zrG5vyksZsa/vHT6adzf4Utu/s4j2sDrP+0rDtbHbV7719xIfVYX/+su1st35jEixSiROpKMolOgCoOXwTvZ7uLwAAAABJRU5ErkJggg==" width="213" height="77" class="img_ev3q"></p>
<p>In the diagram above, values <code>u</code> and <code>v</code> go through unchanged, but <code>v</code> becomes available on the right side only when <code>u</code> becomes available. However, because there are separate synchronization bars and an additional signal line, the availability of <code>v</code> has no effect on the availability of <code>u</code>.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="delays-and-timers">Delays and timers<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#delays-and-timers" class="hash-link" aria-label="Direct link to Delays and timers" title="Direct link to Delays and timers">​</a></h3>
<p>In order to represent time-dependent behavior of the system, we introduce the <em>delay</em> component:</p>
<p><img decoding="async" loading="lazy" src="data:image/png;base64,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" width="181" height="72" class="img_ev3q"></p>
<p>or alternatively:</p>
<p><img decoding="async" loading="lazy" src="data:image/png;base64,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" width="145" height="60" class="img_ev3q"></p>
<p>Values <code>d</code> and <code>v</code> go through the delay component unchanged, but, in normal operation, value <code>v</code> becomes available on the second output with a delay of at least time duration <code>d</code>.</p>
<p>Using the delay component, we can construct a timer component that passes an arbitrary value through the <code>trigger</code> line, and then, after a given amount of time provided on the <code>duration</code> line, lets a unit value to pass through the <code>signal</code> line (which would normally be connected to a source of an immediately available unit value):</p>
<p><img decoding="async" loading="lazy" src="https://replica-io.dev/assets/images/timer-46d70c16bbf2d5c157facbf705d366d1.png" width="710" height="154" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="one-shot-and-composite-lines">One-shot and composite lines<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#one-shot-and-composite-lines" class="hash-link" aria-label="Direct link to One-shot and composite lines" title="Direct link to One-shot and composite lines">​</a></h3>
<p>Individual inputs and outputs, and therefore interaction lines composed thereof, are conceptually <em>one-shot</em>, i.e. they can convey only a single data item. However, we can bundle multiple inputs/outputs together and thus construct <em>composite inputs/outputs and interaction lines</em>. There is <em>no synchronization</em> imposed by composing interaction lines together, i.e. each individual line remains <em>concurrent in composition</em>.</p>
<p>We can compose two interaction lines together and decompose them back by constructing and deconstructing a pair, graphically represented as follows:</p>
<p><img decoding="async" loading="lazy" src="data:image/png;base64,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" width="331" height="49" class="img_ev3q"></p>
<p>We can also uniformly bundle an arbitrary number of lines together as follows:</p>
<p><img decoding="async" loading="lazy" src="https://replica-io.dev/assets/images/mux-e1725c67bfe918c18636b79e7ddf6c20.png" width="602" height="226" class="img_ev3q"></p>
<p>In the diagram above, the source labeled with the bang symbol <code>!</code> denotes an empty source. (With just two lines being multiplexed uniformly, the notation above appears the same as the one for constructing a pure pair; in such cases, the ambiguity will be resolved by the context.)</p>
<p>Using this notation, we can also bundle a virtually indefinite number of lines together:</p>
<p><img decoding="async" loading="lazy" src="data:image/png;base64,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" width="472" height="84" class="img_ev3q"></p>
<p>Note that the line composition primitives are not components: there is neither interaction nor synchronization between individual interaction lines caused by the composition; this is just notational convenience for dealing with multiple interaction lines.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="transposition">Transposition<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#transposition" class="hash-link" aria-label="Direct link to Transposition" title="Direct link to Transposition">​</a></h3>
<p>It may be useful to rearrange the elements within a composition. We can transpose the last two levels of a composition as follows:</p>
<p><img decoding="async" loading="lazy" src="https://replica-io.dev/assets/images/transpose-d7d27617d06f46e124509400da0fe67a.png" width="427" height="356" class="img_ev3q"></p>
<p>The transposer connects line <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span> from composite line <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><mi>m</mi><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x^{mn}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">mn</span></span></span></span></span></span></span></span></span></span></span></span> on the left to line <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">y_{j,i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span> of composite line <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mrow><mi>n</mi><mi>m</mi></mrow></msup></mrow><annotation encoding="application/x-tex">y^{nm}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8588em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">nm</span></span></span></span></span></span></span></span></span></span></span></span> on the right. For example, it will rearrange</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">[ [u, v, w], [x, y, z] ]</span><br></span></code></pre></div></div>
<p>into</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">[ [u, x], [v, y], [w, z] ]</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-select-component">The <code>Select</code> component<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#the-select-component" class="hash-link" aria-label="Direct link to the-select-component" title="Direct link to the-select-component">​</a></h3>
<p>Using composite interaction lines we can define a component representing a choice from an arbitrary number of options:</p>
<p><img decoding="async" loading="lazy" src="data:image/png;base64,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" width="236" height="96" class="img_ev3q"></p>
<p>In the <code>Select</code> component, the first input, <code>choice</code>, determines the value of which element from the second, composite input, <code>options</code>, should become available on the third output, <code>chosen</code>. The <code>chosen</code> input is supposed to be connected to a source of unspecified values. The <code>choice</code> input can also be left unspecified; in that case, the component chooses it to select the element of <code>options</code> that becomes available earlier.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="uncluttering-diagrams">Uncluttering diagrams<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#uncluttering-diagrams" class="hash-link" aria-label="Direct link to Uncluttering diagrams" title="Direct link to Uncluttering diagrams">​</a></h3>
<p>To unclutter diagrams, we may depict several connections in one stroke and omit sources of unspecified values and sinks like this:</p>
<p><img decoding="async" loading="lazy" src="https://replica-io.dev/assets/images/buses-e2bea611118c18b5333627c1e85295cb.png" width="437" height="342" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="repetitive-patterns">Repetitive patterns<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#repetitive-patterns" class="hash-link" aria-label="Direct link to Repetitive patterns" title="Direct link to Repetitive patterns">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="replication-box">Replication box<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#replication-box" class="hash-link" aria-label="Direct link to Replication box" title="Direct link to Replication box">​</a></h4>
<p>We would often need to connect one or many components in a repetitive pattern. To represent such patterns in a diagram, we can depict a single instance of the repeating part of the diagram enclosed in a <em>replication box</em>:</p>
<p><img decoding="async" loading="lazy" src="https://replica-io.dev/assets/images/replication-box-f79d6f507442df2145f321078ddbae41.png" width="579" height="191" class="img_ev3q"></p>
<p>In the diagram above, component <code>G</code> enclosed in a replication box is virtually repeated for each element of the composite lines entering and exiting the replication box.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="recursive-loops">Recursive loops<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#recursive-loops" class="hash-link" aria-label="Direct link to Recursive loops" title="Direct link to Recursive loops">​</a></h4>
<p>We can use the replication box to represent recursive patterns of connections as follows:</p>
<p><img decoding="async" loading="lazy" src="https://replica-io.dev/assets/images/recursion-ca122da3ca876a1a3187db0c85dce998.png" width="557" height="532" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="domains-and-projections">Domains and projections<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#domains-and-projections" class="hash-link" aria-label="Direct link to Domains and projections" title="Direct link to Domains and projections">​</a></h3>
<p>Each interaction line belongs to a certain <em>domain</em>, which characterizes its location. For example, we can define a separate domain for each node of a distributed system. Interaction lines cannot cross domain boundaries, but <em>some components may span multiple domains</em> and thus enable <em>cross-domain interaction</em>.</p>
<p>We can then derive a <em>projection</em> of a system model onto a subset of its domains. Connections with base components that span the projection boundary will be represented as extrinsic inputs and outputs. So we can project a model of the whole distributed system separately onto each node and derive the local logic of individual nodes. The base components that represent means of communication between nodes, which are necessarily cross-domain, will be replaced by extrinsic inputs and outputs standing for gateways to the networking layer.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="assume-guarantee-reasoning-and-modelling-of-faults">Assume-guarantee reasoning and modelling of faults<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#assume-guarantee-reasoning-and-modelling-of-faults" class="hash-link" aria-label="Direct link to Assume-guarantee reasoning and modelling of faults" title="Direct link to Assume-guarantee reasoning and modelling of faults">​</a></h3>
<p>The behavior of individual components could be specified in terms of the assumptions about their inputs and the guarantees about their outputs. This would enable <em>assume-guarantee reasoning</em> about correctness of the system and <em>compositional verification</em>. In the context of distributed systems, benign node faults can be modeled by suppressing some extrinsic sources belonging to the corresponding domains, whereas Byzantine faults can be modeled by forcing some of the extrinsic sources with arbitrary values ("garbage in — garbage out").</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="confining-interaction-lines">Confining interaction lines<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#confining-interaction-lines" class="hash-link" aria-label="Direct link to Confining interaction lines" title="Direct link to Confining interaction lines">​</a></h3>
<p>The total number of interaction lines in complex components can quickly become too large. Therefore, components should only expose a subset of input-output pairs that is enough to guarantee determinism and reversibility under the component's assumptions, <em>confining</em> the remaining interaction lines by connecting them to sources and sinks inside the component. For example, in distributed protocols, the exact set of votes forming a valid quorum for certain decisions of the protocol logic often does not affect the outcomes, given the assumptions about the maximal fraction of faulty nodes hold true; so the corresponding interaction lines can be confined within a component representing the protocol.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="modelling-distributed-protocols">Modelling Distributed Protocols<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#modelling-distributed-protocols" class="hash-link" aria-label="Direct link to Modelling Distributed Protocols" title="Direct link to Modelling Distributed Protocols">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="brachas-reliable-broadcast">Bracha's Reliable Broadcast<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#brachas-reliable-broadcast" class="hash-link" aria-label="Direct link to Bracha's Reliable Broadcast" title="Direct link to Bracha's Reliable Broadcast">​</a></h3>
<p>Now we'll try to apply the approach to modelling a relatively simple distributed protocol, namely Bracha's broadcast<sup><a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#user-content-fn-bracha-broadcast-91b34d" id="user-content-fnref-bracha-broadcast-91b34d" data-footnote-ref="true" aria-describedby="footnote-label">2</a></sup>. Bracha's broadcast is a foundational distributed protocol implementing a Byzantine fault-tolerant reliable broadcast mechanism in the asynchronous model. The protocol allows one party to broadcast a message such that all correct parties eventually deliver the message and agree on the delivered message, given that less than a third of the parties may be corrupt. The protocol adopts the asynchronous model, i.e. it makes no timing assumptions but requires that every message sent by a correct process is eventually received.</p>
<p>For the sake of simplicity, we will model a one-shot version of the protocol that only allows broadcasting a single value from a designated sender party. The protocol can be expressed in traditional event-oriented pseudo-code as follows:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">upon broadcast(m): // only sender</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">	send message &lt;SEND, m&gt; to all</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">upon receiving a message &lt;SEND, m&gt; from the sender:</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">	send message &lt;ECHO, m&gt; to all</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">upon receiving n-f messages &lt;ECHO, m&gt; and not having sent a READY message:</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">	send message &lt;READY, m&gt; to all</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">upon receiving f+1 messages &lt;READY, m&gt; and not having sent a READY message:</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">	send message &lt;READY, m&gt; to all</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">upon receiving n-f messages &lt;READY, m&gt;:</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">	deliver(m)</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="peer-to-peer-links">Peer-to-peer links<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#peer-to-peer-links" class="hash-link" aria-label="Direct link to Peer-to-peer links" title="Direct link to Peer-to-peer links">​</a></h4>
<p>We will start by modelling communication between individual nodes in the system. Each party in the protocol is represented by a node, and each node is modeled as a separate domain. For the nodes to communicate, those domains need to be able to interact through some kind of cross-domain component. So we define the following component for that purpose:</p>
<p><img decoding="async" loading="lazy" src="https://replica-io.dev/assets/images/link-ac72897f9324a3a2b6c3b92973e81fd0.png" width="568" height="119" class="img_ev3q"></p>
<p>The <code>Link</code> component allows sending an authenticated value from one node to another. If the <code>rcv</code> input is left unspecified, as supposed, the component chooses the value from the <code>snd</code> input as the value of the <code>rcv</code> output.  The <code>snd</code> line belongs to the message sender's domain, whereas the <code>rcv</code> line belongs to the destination node's domain. If we treat <code>Link</code> as a composite component, we can model it as shown on the right side of the diagram above, where the internal interaction line in the middle belongs to a separate domain and represents the communication medium.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="weak-broadcast">Weak broadcast<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#weak-broadcast" class="hash-link" aria-label="Direct link to Weak broadcast" title="Direct link to Weak broadcast">​</a></h4>
<p>Although the underlying communication mechanism is point-to-point message exchange, if we look closer, the basic communication pattern used in the reliable broadcast protocol is sending the same message to all nodes. Let's refer to this pattern as weak broadcast and represent it as the following component:</p>
<p><img decoding="async" loading="lazy" src="https://replica-io.dev/assets/images/wb-8d384dc3a7414e2c7ad06b5b80b4231c.png" width="603" height="179" class="img_ev3q"></p>
<p>The <code>bc</code> line belongs to the sending node's domain, whereas the elements of the composite <code>dlvr</code> line belong to the corresponding receiving nodes' domains. We can model a corrupt sender committing the failure of message equivocation (sending different messages to some receivers) by forcing some of the sources in its domain with arbitrary values. The component is mainly composed of <code>Link</code> and <code>Def</code> components replicated for each receiving node. The <code>Def</code> components are meant to create an individual copy of the <code>bc</code> value for each instance of <code>Link</code>. Note the recursive pattern, used together with the replication box, that forms a kind of forward loop in order to thread the value from the <code>bc</code> input through the replicated components.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="quorums">Quorums<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#quorums" class="hash-link" aria-label="Direct link to Quorums" title="Direct link to Quorums">​</a></h4>
<p>Another kind of component that we will need is for collecting quorums of values received from peer nodes:</p>
<p><img decoding="async" loading="lazy" src="https://replica-io.dev/assets/images/rb-quorums-2c6c8868f139f8870bd2bd59efbf3f6b.png" width="614" height="72" class="img_ev3q"></p>
<p>The <code>WeakQuroum</code> and <code>StrongQuorum</code> components are identical except the number of votes required to reach the quorum: <code>f+1</code> and <code>n-f</code>, respectively. <code>WeakQuorum</code> ensures that there is at least one vote from a correct node, whereas <code>StrongQuorum</code> ensures that any two of such quorums must intersect in at least one correct node. Moreover, <code>StrongQuorum</code> ensures that any of its quorums contains at least as many votes from correct nodes as the total number of votes required by <code>WeakQuorum</code>. The <code>votes</code> line represents the values received from peer nodes, whereas the <code>value</code> line represents the value supported by a sufficient quorum of votes. If the <code>value</code> input is left unspecified then the component will choose the value corresponding to the earliest quorum of votes becoming available; if the <code>value</code> input is forced then the component will make the complementary output available only once a quorum becomes available on the <code>votes</code> input.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="overall-protocol-model">Overall protocol model<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#overall-protocol-model" class="hash-link" aria-label="Direct link to Overall protocol model" title="Direct link to Overall protocol model">​</a></h4>
<p>Now we can model the Bracha's reliable broadcast protocol as a cross-domain component with an interface identical to <code>WB</code> but providing the guarantees of reliable broadcast:</p>
<p><img decoding="async" loading="lazy" src="https://replica-io.dev/assets/images/bracha-broadcast-faf2f72eba81973b69288e83fb42fb7f.png" width="722" height="698" class="img_ev3q"></p>
<p>In this diagram, we omit sources of unspecified values and sinks. We also omit types, but indicate the dimentionality of composite lines. We label the instances of the  <code>WB</code> component with names: <code>send</code>, <code>echo</code>, and <code>ready</code>, indicating the kind of protocol message being communicated through those components.</p>
<p>The <code>send</code> component is used to send a value from the designated sender node to all nodes, whereas the <code>echo</code> and <code>ready</code> components are replicated for each node and represent all-to-all communication. Note that the composite <code>dlvr</code> outputs of the <code>WB</code> components replicated for each node sending <code>ECHO</code> and <code>READY</code> messages go through transposers outside of replication boxes. Remember that individual lines of the <code>dlvr</code> output belong to the corresponding receiving nodes' domains, but we need to connect the <code>votes</code> inputs of the quorum components so that they all belong to the same node's domain. The trasnposers rearrange the composite lines to achieve that.</p>
<p>The <code>Select</code> component, replicated for each node, represents a choice between two alternative causes for sending a <code>READY</code> message: either upon receiving a strong quorum of <code>ECHO</code> messages or upon receiving a weak quorum of <code>READY</code> message from other nodes.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="consistent-broadcast-and-modularized-protocol-model">Consistent broadcast and modularized protocol model<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#consistent-broadcast-and-modularized-protocol-model" class="hash-link" aria-label="Direct link to Consistent broadcast and modularized protocol model" title="Direct link to Consistent broadcast and modularized protocol model">​</a></h4>
<p>We should recognize that a part of this reliable broadcast protocol actually represents a consistent broadcast protocol. Consistent broadcast guarantees that receivers agree on the delivered values, but it does not guarantee that all correct receivers eventually deliver the value even if some correct receivers deliver. We can represent this sub-protocol as a cross-domain component:</p>
<p><img decoding="async" loading="lazy" src="https://replica-io.dev/assets/images/cb-63d00e1654ca924de4183453f788a781.png" width="439" height="497" class="img_ev3q"></p>
<p>and then restructure the reliable broadcast protocol as follows:</p>
<p><img decoding="async" loading="lazy" src="https://replica-io.dev/assets/images/bracha-broadcast-from-cb-4241ea2d2b4e7c05f939d6609c92a330.png" width="595" height="414" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="tendermint-consensus">Tendermint Consensus<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#tendermint-consensus" class="hash-link" aria-label="Direct link to Tendermint Consensus" title="Direct link to Tendermint Consensus">​</a></h3>
<p>Now we'll try to apply the approach to a more complicated protocol and sketch a model of the Tendermint consensus protocol<sup><a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#user-content-fn-tendermint-91b34d" id="user-content-fnref-tendermint-91b34d" data-footnote-ref="true" aria-describedby="footnote-label">3</a></sup>. Tendermint is a Byzantine fault-tolerant sequence consensus protocol (a.k.a. total order broadcast or atomic broadcast), which allows nodes to agree on a single growing sequence of values where values can be proposed by different nodes. The protocol adopts the partially synchronous model, i.e. it assumes that eventually all messages are delivered within certain time bound, although there might be periods of asynchrony in the system. The timing assumptions complicate modelling by adding more non-determinism and appear in the protocol in a form of timeouts.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="gossip-communication">Gossip communication<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#gossip-communication" class="hash-link" aria-label="Direct link to Gossip communication" title="Direct link to Gossip communication">​</a></h4>
<p>The Tendermint protocol relies upon a gossip-based mechanism for communication between nodes: a node can broadcast a message through the gossip mechanism and it will be delivered at all correct nodes. Moreover, if a correct node delivers a message from the gossip mechanism then the same message is guaranteed to be delivered at all other correct nodes. We will model this communication mechanism as the following cross-domain component:</p>
<p><img decoding="async" loading="lazy" src="data:image/png;base64,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" width="265" height="72" class="img_ev3q"></p>
<p>The <code>bc</code> line belongs to the sending node and represents the set of values broadcast through this instance of the gossip mechanism; each element of the <code>dlvr</code> line belongs to the corresponding receiving node and represents the set of values delivered from that instance of the gossip mechanism.</p>
<p>Individual elements in the <code>Set</code> type are concurrent and can become available independently of each other. We can think of the <code>Set&lt;T&gt;</code> type as a composition of single-bit lines, each representing the presence or absence of a particular value of <code>T</code> in the set.</p>
<p>If the <code>bc</code> line belongs to a correct node then the same set of values becomes available on all elements of the <code>dlvr</code> output that belong to correct nodes as the set of values on the <code>bc</code> input. Moreover, if any value becomes available on one element of <code>dlvr</code> of a correct node then the same value also becomes available on all correct nodes' elements of <code>dlvr</code>.</p>
<p>Correct nodes in the Tendermint protocol only ever broadcast a single value through each instance of the <code>Gossip</code> component; however, Byzantine nodes may broadcast multiple values and all correct nodes would eventually deliver all of those values from that instance of the <code>Gossip</code> component.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="overall-protocol-model-1">Overall protocol model<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#overall-protocol-model-1" class="hash-link" aria-label="Direct link to Overall protocol model" title="Direct link to Overall protocol model">​</a></h4>
<p>Nodes in the Tendermint protocol decide on a single value at each <em>height</em> in the growing sequence of values. At each height, the protocol may need one or multiple <em>rounds</em> in order to reach agreement between nodes and determine the decision value to <em>commit</em> at that height. Each round consists of the <em>proposal</em>, <em>prevote</em>, and <em>precommit</em> stages. So we can model the overall protocol as the following cross-domain component:</p>
<p><img decoding="async" loading="lazy" src="https://replica-io.dev/assets/images/tendermint-062837ffcc9c51df197984fd09145c54.png" width="418" height="356" class="img_ev3q"></p>
<p>Here, again, we omit sources of unspecified values and sinks, omit most of the types, but indicate the dimentionality of composite lines with superscript indeces.</p>
<p>The <code>Tendermint</code> component represents the overall protocol. Its composite <code>value</code> input represents the values that would be proposed by each node (index <code>n</code>) in each round (index <code>r</code>) at each height (index <code>h</code>); the <code>proposer</code> input represent the designated proposer for each round at each height; the <code>decision</code> output represents the decision value by each node at each height. Finally, the composite <code>aux</code> line represents the auxiliary lines added for each height in order to satisfy the determinism and reversibility requirements.</p>
<p>The <code>Height</code> component represents the protocol logic for each height. Its interaction lines are mostly identical to those of the <code>Tendermint</code> component, without the last level of composition, except that the auxiliary line is represented more explicitly. Namely, the <code>aux</code> line of <code>Tendermint</code> is composed of the following lines of <code>Height</code>: <code>decisionRound</code> representing the round number in which each nodes commits the decision value, <code>timeouts</code> and <code>aborts</code> representing timeouts and aborts happened at each node in each round.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="height-component"><code>Height</code> component<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#height-component" class="hash-link" aria-label="Direct link to height-component" title="Direct link to height-component">​</a></h4>
<p>We model the <code>Height</code> component as follows:</p>
<p><img decoding="async" loading="lazy" src="https://replica-io.dev/assets/images/tendermint-height-a712b260493df571a291f959fd329626.png" width="746" height="617" class="img_ev3q"></p>
<p>The <code>Round</code> component represents a single instance of the repetitive part of the protocol that includes the proposal, prevote, and precommit stages, in which a designated proposer broadcasts a proposal proposing a decision value to all nodes who can then broadcast prevote and precommit votes for the proposed value. At each node, instead of voting for the proposal, the prevote and precommit stages may timeout, in which case the node broadcasts a special <code>nil</code> vote, or abort, in which case the node does not broadcast any vote in that stage of the round; the propose stage can also abort. As we'll see later, the rounds and stages are coordinated by the signals from the <code>pmSignals</code> input. Those signals are required for the round stages to broadcast a proposal or vote, to timeout, or to abort. The actual timeout and abort decisions are represented by the <code>timeouts</code> and <code>aborts</code> lines.</p>
<p>The Tendermint protocol defines certain conditions that a proposal must satisfy in order to be voted for. Those conditions depend on the outcomes of the previous round, so there is a forward loop, represented by the <code>loopFwd</code> line, that connects successive instances of the replicated <code>Round</code> component and conveys the required values from the previous to the next round.</p>
<p>The <code>Commit</code> component represents the decision logic of the protocol that is replicated for each node. Given the proposal and precommit votes from each round, it determines the single decision by selecting the value proposed in one of the rounds, the decision round, for which there exists a strong quorum of matching precommit votes.</p>
<p>The <code>Pacemaker</code> component coordinates the rounds and stages of the protocol by making the corresponding signals available according to the required dynamics of the protocol. We'll see those signals connected to the corresponding components in the next diagram.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="round-component"><code>Round</code> component<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#round-component" class="hash-link" aria-label="Direct link to round-component" title="Direct link to round-component">​</a></h4>
<p>We model the <code>Round</code> component as follows:</p>
<p><img decoding="async" loading="lazy" src="https://replica-io.dev/assets/images/tendermint-round-23830d35b08a03266bc9bcf40884222a.png" width="1100" height="898" class="img_ev3q"></p>
<p>The <code>Propose</code>, <code>Prevote</code>, and <code>Precommit</code> components represent the stages of the protocol logic and determine the values of the corresponding messages to broadcast through the gossip mechanism. <code>Prevote</code> and <code>Precommit</code> are replicated so that there are individual instances for each node. Note that there are separate instances of the <code>Gossip</code> component for each node and stage, except for the proposal that is broadcast only by the designated proposer node, and those instances are replicated in the overall protocol component for each round and height. This way, there is no need to include the message tag, height and round numbers in the values that are broadcast through the <code>Gossip</code> component instances. The composite lines representing all-to-all communication go through transposers outside of the replication boxes in order to rearrange their components appropriately.</p>
<p>The <code>validVR</code> and <code>lockedVR</code> are composite lines representing <code>(validValue, validRound)</code> and <code>(lockedValue, lockedRound)</code>, respectively, with the values corresponding to the variables of the same name from the protocol pseudo-code as it is described in the original paper<sup><a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#user-content-fn-tendermint-91b34d" id="user-content-fnref-tendermint-91b34d-2" data-footnote-ref="true" aria-describedby="footnote-label">3</a></sup>. Basically, <code>validVR</code> is used to determine whether the proposer should propose a new value or re-propose a value proposed in one of the previous rounds, <code>lockedVR</code> determines which proposals are safe to cast a prevote for. As we can see from the diagram, the values in those lines are updated in the <code>Precommit</code> component. The <code>prevoteQVals</code> line is a composite line each element of which corresponds to the prevote, if any, supported by a strong quorum in the previous rounds. Note how the <code>prevoteQVals</code> and <code>round</code> lines are updated for each node in a replication box: the composite <code>prevoteQVals</code> line is extended with an additional line connected to the corresponding output of the <code>Precommit</code> component, whereas <code>round</code> is simply incremented by the component labeled with <code>+1</code>.</p>
<p>We will not decompose the components further since the main point was to make a sketch of how we can model the overall structure of the Tendermint protocol, namely the heights, rounds, stages, the interconnection between them, and represent the dynamics of the protocol.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion">Conclusion<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#conclusion" class="hash-link" aria-label="Direct link to Conclusion" title="Direct link to Conclusion">​</a></h2>
<p>We explored a possible way of applying the ideas of reversible deterministic concurrency to modelling distributed protocols. We tried to make the vague ideas a little more concrete and give a better intuition of how an approach based on those ideas may look like by considering some guiding principles, spelling out some details, introducing some primitives and patterns, expressing this in a graphical notation. We considered modelling distributed systems as a whole and then deriving local projections for individual nodes. We also considered how we can model node failures, both benign and Byzantine. Finally, we saw how some concrete, well-known distributed protocols may look like when modeled following this approach.</p>
<p>We also anticipated some potential benefits of the approach, such as modularity, composability, compositional reasoning and verification, absence of hidden data flows, enhanced debugging and verification methods, resource management, representing a distributed system as a whole and then deriving the logic and implementation for its local nodes.</p>
<p>This is just the beginning of developing those ideas into a practical solution. We'll need to see what this approach means for different aspects of designing and implementing distributed protocols. We'll need to invent some kind of textual notation and develop a clear, consistent concept codifying the core principles. We'll need to find a way of implementing those ideas in real code and examine its expressivity and limitations, better understand the benefits and drawbacks. In other words, we need to find a good way of turning this into a solid foundation for our framework.</p>
<!-- -->
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37">❤️</span>Supporting</div><div class="admonitionContent_BuS1"><p>If you like the project and find it valuable, please <a href="https://github.com/sponsors/replica-io">support</a> its further development! 🙏</p></div></div>
<!-- -->
<section data-footnotes="true" class="footnotes"><h2 class="anchor anchorWithStickyNavbar_LWe7 sr-only" id="footnote-label">Footnotes<a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#footnote-label" class="hash-link" aria-label="Direct link to Footnotes" title="Direct link to Footnotes">​</a></h2>
<ol>
<li id="user-content-fn-fredkin-gate-91b34d">
<p>Controlled swap of individual bits is known as <a href="https://en.wikipedia.org/wiki/Fredkin_gate" target="_blank" rel="noopener noreferrer">Fredkin gate</a> in <a href="https://en.wikipedia.org/wiki/Reversible_computing" target="_blank" rel="noopener noreferrer">reversible</a> and <a href="https://en.wikipedia.org/wiki/Quantum_computing" target="_blank" rel="noopener noreferrer">quantum</a> computing; here we generalize it to operate on target values of arbitrary type. <a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#user-content-fnref-fredkin-gate-91b34d" data-footnote-backref="" aria-label="Back to reference 1" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-bracha-broadcast-91b34d">
<p>To learn about Bracha's broadcast in detail, please refer to the <a href="https://ecommons.cornell.edu/bitstream/handle/1813/6430/84-590.pdf" target="_blank" rel="noopener noreferrer">original paper</a>, where it was introduced as a key building block of an asynchronous consensus protocol. The following post may also be helpful: <a href="https://decentralizedthoughts.github.io/2020-09-19-living-with-asynchrony-brachas-reliable-broadcast/" target="_blank" rel="noopener noreferrer">Living with Asynchrony: Bracha's Reliable Broadcast</a>, as well as <a href="https://dcl.epfl.ch/site/_media/education/sdc_byzconsensus.pdf" target="_blank" rel="noopener noreferrer">these lecture notes</a>. <a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#user-content-fnref-bracha-broadcast-91b34d" data-footnote-backref="" aria-label="Back to reference 2" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-tendermint-91b34d">
<p>For a more precise and detailed description of the Tendermint protocol please refer to the <a href="https://arxiv.org/pdf/1807.04938" target="_blank" rel="noopener noreferrer">original paper</a>. <a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#user-content-fnref-tendermint-91b34d" data-footnote-backref="" aria-label="Back to reference 3" class="data-footnote-backref">↩</a> <a href="https://replica-io.dev/blog/2025/05/30/a-sketch-of-reversible-deterministic-concurrency-for-distributed-protocols#user-content-fnref-tendermint-91b34d-2" data-footnote-backref="" aria-label="Back to reference 3-2" class="data-footnote-backref">↩<sup>2</sup></a></p>
</li>
</ol>
</section>]]></content>
        <author>
            <name>Sergey Fedorov</name>
            <email>sergefdrv@replica-io.dev</email>
            <uri>https://github.com/sergefdrv</uri>
        </author>
        <category label="technical" term="technical"/>
        <category label="long" term="long"/>
        <category label="notes" term="notes"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[On Frameworks for Implementing Distributed Protocols]]></title>
        <id>https://replica-io.dev/blog/2024/08/27/on-frameworks-for-implementing-distributed-protocols</id>
        <link href="https://replica-io.dev/blog/2024/08/27/on-frameworks-for-implementing-distributed-protocols"/>
        <updated>2024-08-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[A post concluding exploration of 7 frameworks for implementing distributed protocols.]]></summary>
        <content type="html"><![CDATA[<p>This post concludes the second phase of the <a href="https://github.com/replica-io/replica-io/issues/7" target="_blank" rel="noopener noreferrer">state-of-the-art exploration</a> in the scope of milestone <a href="https://github.com/replica-io/replica-io/milestone/1" target="_blank" rel="noopener noreferrer">M0.1</a> of the Replica_IO project, namely exploration of existing frameworks for implementing distributed protocols. It shares the main conclusions drawn from exploring 7 different frameworks.</p>
<div class="theme-admonition theme-admonition-note admonition_xJq3 alert alert--secondary"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</div><div class="admonitionContent_BuS1"><p>A companion video is available <a href="https://youtu.be/oRQG6EBzVe4" target="_blank" rel="noopener noreferrer">here</a>.</p></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="exploring-distributed-protocol-frameworks">Exploring Distributed Protocol Frameworks<a href="https://replica-io.dev/blog/2024/08/27/on-frameworks-for-implementing-distributed-protocols#exploring-distributed-protocol-frameworks" class="hash-link" aria-label="Direct link to Exploring Distributed Protocol Frameworks" title="Direct link to Exploring Distributed Protocol Frameworks">​</a></h2>
<p>Trying to make a real breakthrough, such as what the Replica_IO project aims at, it is important to learn from prior attempts to deal with the problem. Having explored how real-world code bases typically implement the core distributed protocols like consensus and having summarized the findings in <a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols" target="_blank" rel="noopener noreferrer">the previous post</a>, I continued the exploration by surveying existing attempts to find a better approach to the problem, i.e. different frameworks for implementing distributed protocols.</p>
<p>I looked at the documentation and examples provided by each of the frameworks, as well as into their implementation, in order to figure out how they model and structure distributed systems, what kind of notation is used to specify and implement distributed protocols in those frameworks, what is their approach to communication, concurrency, and composition of protocol components, and what they offer for ensuring the correctness of protocols and their implementations.</p>
<p>After having explored each of the frameworks, I summarized and shared some of my findings. You can find those overviews on <a href="https://github.com/replica-io/replica-io/wiki/State-of-the-art-exploration" target="_blank" rel="noopener noreferrer">this wiki page</a>.</p>
<p>Here is the full list of 7 frameworks, based on different programming languages, that I explored<sup><a href="https://replica-io.dev/blog/2024/08/27/on-frameworks-for-implementing-distributed-protocols#user-content-fn-other-frameworks-ef0b52" id="user-content-fnref-other-frameworks-ef0b52" data-footnote-ref="true" aria-describedby="footnote-label">1</a></sup>:</p>
<ul>
<li><a href="https://github.com/consensus-shipyard/mir" target="_blank" rel="noopener noreferrer">Mir</a> — a framework for implementing, debugging, and analyzing distributed protocols (based on Go);</li>
<li><a href="https://github.com/SecureSolutionsLab/Atlas" target="_blank" rel="noopener noreferrer">Atlas</a> — a modular framework for building distributed mechanisms focused on configurability and performance (based on Rust);</li>
<li><a href="https://github.com/pfouto/babel-core" target="_blank" rel="noopener noreferrer">Babel</a> — a generic framework for implementing and executing distributed protocols (based on Java);</li>
<li><a href="https://distal.github.io/" target="_blank" rel="noopener noreferrer">DiStaL</a> — a framework for implementing and executing distributed protocols (based on Scala);</li>
<li><a href="https://github.com/dzufferey/psync" target="_blank" rel="noopener noreferrer">PSync</a> — a framework for implementing and verifying fault-tolerant distributed protocols (based on Scala);</li>
<li><a href="https://github.com/DistributedComponents/disel" target="_blank" rel="noopener noreferrer">Disel</a> — a framework for implementation and compositional machine-assisted verification of distributed systems and their clients (based on Coq);</li>
<li><a href="https://github.com/uwplse/verdi" target="_blank" rel="noopener noreferrer">Verdi</a> — a framework for implementing and formally verifying distributed systems (based on Coq).</li>
</ul>
<p>In the subsequent sections, I will share some of the observations and conclusions I made while exploring those frameworks. I decided to structure the discussion around the following aspects:</p>
<ul>
<li><em>model</em>: how distributed systems and their components are modeled;</li>
<li><em>structure</em>: how distributed protocol components are structured and composed together;</li>
<li><em>notation</em>: what kind of notation is used to specify and implement distributed protocols;</li>
<li><em>operation</em>: how distributed protocol components are executed and interact with each other;</li>
<li><em>verification</em>: how distributed protocols and their implementations are verified for correctness.</li>
</ul>
<p>But before we go into details, I would like to note that most of those frameworks were purely academic efforts and almost all of them seem to be abandoned now; unfortunately, they didn't seem to have found practical use. Nevertheless, it was good to learn from them. Let's now dive in.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="model">Model<a href="https://replica-io.dev/blog/2024/08/27/on-frameworks-for-implementing-distributed-protocols#model" class="hash-link" aria-label="Direct link to Model" title="Direct link to Model">​</a></h2>
<p>The way that systems and their components are modeled has a profound effect on the structure and shape of their specifications and implementation, on the operational aspects and verification for correctness. We can consider different levels of abstraction when modeling distributed systems: the high-level model of the system as a whole, the model of individual nodes within the system, as well as individual protocols and components within the nodes. Let's take a look at how the explored frameworks model distributed systems and their components.</p>
<p>The common approach is to model distributed systems at high level as <a href="https://en.wikipedia.org/wiki/Transition_system" target="_blank" rel="noopener noreferrer">state transition systems</a> where the global system state changes upon external and internal events, such as client requests, messages exchanged within the system, and timeouts. In this model, the global system state includes the states of all individual nodes and their components, as well as the environment state. The environment state usually includes the state of the network the nodes communicate through, in particular the messages in transit. Transitioning from one state to another happens according to a global <em>transition function</em> triggered by events. The transition function receives the current state of the system together with the triggering event and returns the new system state.</p>
<p>The explored frameworks follow the <a href="https://en.wikipedia.org/wiki/Message_passing" target="_blank" rel="noopener noreferrer">message-passing</a> approach, where the states of individual nodes and protocol components are disjoint, i.e. different parts do not share pieces of state. Interaction between nodes happens through the network by sending and receiving messages. Sending and receiving of messages are modeled as events modifying the global system state by updating the set of messages in transit in the network state and, in case of message receiving, the state of the target component in the destination node. For example, in Disel, the system state includes a "message soup" for each protocol, which models the current state and the history of the network.&nbsp;In Disel's abstract model, messages are&nbsp;never removed&nbsp;from the message soup, instead they are marked either as active or consumed.</p>
<p>Nodes and network failures are modeled as special events, e.g. dropping or duplicating messages in the network, disabling normal event handling in faulty nodes or (partially) resetting their state. Some of the frameworks only consider crash faults, leaving <a href="https://en.wikipedia.org/wiki/Byzantine_fault" target="_blank" rel="noopener noreferrer">Byzantine faults</a> for the future work. The system models in most of the frameworks do not seem to include timing assumption, so they can be considered asynchronous. In contrast, PSync employs the Heard-Of model based on communication-closed rounds, which provides an illusion of simple synchronous communication on top of the partial synchrony of the actual underlying network. In this model, protocol execution proceeds in explicit rounds, alternating communication with protocol state transition based on the set of messages received during the round. Network and node faults in this model are unified, and the network assumptions are specified in terms of the heard-of sets.</p>
<p>Communication between nodes is predominantly modeled as fire-and-forget message delivery, where messages can be reordered or dropped by the network abstraction. Though, in Verdi, protocols are first modeled with an idealistic, reliable network semantics, which can then be translated&nbsp;into weaker fault models using&nbsp;verified system transformers. Babel allows modeling protocols in stronger communication models using communication channel abstractions, which represent communication mechanisms with different properties and guarantees.</p>
<p>Individual components within nodes are commonly modeled as sequential, event-driven state machines interacting with each other via reliable message passing. The message passing normally follows the one-to-one one-way or request-response patterns; however, some of the frameworks also support one-to-many notifications between components. Some frameworks (e.g., Verdi) explicitly distinguish between the events that are external to the distributed protocol, like client requests, and internal events, like exchanging messages between protocol components and nodes within the distributed system.</p>
<p>To overcome the limitations of strict state separation between protocol components in the abstract model, Disel allows coupling protocols via inter-protocol behavioral dependencies, called send-hooks, which allow restricted logical access to other protocol's state. Disel doesn't seem to strictly follow the message-passing model for protocol components within the same node, supporting generic composition of protocol components. Disel also provides mechanisms to establish stronger properties of protocols and their combinations by strengthening them with additional inductive invariants.</p>
<p>As we can see, although there are some interesting variations and extensions, the underlying system model in the explored frameworks is largely the same, namely the one of a state transition system composed of components, which are sequential, event-driven state machines with disjoint state, interacting via message passing. This is remarkably similar to how distributed protocols are usually implemented in real-world code bases, which do not use any framework, as I described in <a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols" target="_blank" rel="noopener noreferrer">the previous post</a>. This approach tends to shift the focus more to the operational rather than functional and logical aspects of the system. There I also pointed out, when discussing how protocol implementations attempt to <a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#evading-concurrency" target="_blank" rel="noopener noreferrer">evade concurrency</a>, that this approach may complicate the implementation and cause fragmentation of the protocol logic. Perhaps, adopting the same kind of the underlying model is one of the reasons why the explored frameworks do not seem to have made a real breakthrough in designing and implementing distributed protocols.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="structure">Structure<a href="https://replica-io.dev/blog/2024/08/27/on-frameworks-for-implementing-distributed-protocols#structure" class="hash-link" aria-label="Direct link to Structure" title="Direct link to Structure">​</a></h2>
<p>In all of the explored frameworks, protocol implementations rely on some kind of runtime or shim provided by the framework, hiding low-level concerns from implementation of the protocol logic. In most of the frameworks, the runtime is responsible for coordinating the execution of protocol components and interaction between them; some of the frameworks also provide there dedicated interfaces for communication over the network and setting timers. Protocol components normally need to be registered within the runtime before they can function within the system.</p>
<p>In most cases, protocol components within the same node can interact by simply sending some kind of internal messages to each other, without establishing any explicit connection. In contrast, components in Atlas require explicit orchestration of the interaction with the rest of the system. Disel instead supports composition of components expressed as effectful functional programs; it also allows loosely coupling protocol components via inter-protocol behavioral dependencies, called send-hooks, at the formal specification level.</p>
<p>Since the runtime in Mir is only responsible for coordinating the execution of protocol components and interaction between them, there are special components that provide functionality for sending and receiving messages over the network, as well as for setting local timers and for cryptographic operations. Mir explicitly distinguishes between passive components, which can only produce events synchronously, as a result of processing input events provided by the runtime, and active components, which can asynchronously produce new events on their own.</p>
<p>There are frameworks that provide means for enhancing protocol components with additional properties. Disel provides a protocol combinator&nbsp;<code>ProtocolWithIndInv</code>, which&nbsp;allows elaborating a protocol by strengthening it with additional inductive invariants. Verdi provides verified system transformers, which allow transforming protocols specified, implemented, and verified in an idealistic, reliable network semantics into an equivalent implementation, preserving the transformed system properties under a weaker fault model. PSync provides a class, which can be used to wrap protocol round instances to support updating progress conditions and synchronizing rounds in a Byzantine setting.</p>
<p>There are two main approaches to structure interaction of distributed protocols with the rest of the application. Some frameworks provide a mechanism for interacting with protocol components by sending and receiving messages, same as protocol components interact with each other. Other frameworks allow defining dedicated interfaces for that purpose, featuring callable methods or special IO events. In some of the frameworks, protocol components are supplied with some kind of handles to trigger side effects, such as sending messages or setting up timers; in other frameworks, side effects only happen after returning the control back to the runtime, e.g. through the return value or using a monadic structure.</p>
<p>Protocol components commonly consist of the component's state and protocol logic structured as handlers modifying the state or state transition functions, which are triggered by the runtime upon certain events or conditions. In Distal and Disel, the handlers/transitions can be augmented with guarding conditions that must hold in order to trigger the action.</p>
<p>The round-based model in PSync imposes a particular structure of protocol components. Protocol components in PSync must specify a sequence of protocol rounds. Each round, in general, consists of methods to: initialize the round, send messages at the beginning of the round, process received messages, and finally update the internal state before transitioning into the next round.</p>
<p>PSync and Disel explicitly separate the protocol specification from its implementation, whereby the specification is used to formally verify the implementation. Protocol specifications in PSync consist of protocol properties, as well as safety and liveness predicates (assumptions). In order to aid automated verification in PSync, the specification should also include round and/or phase invariants; round transition relations are automatically derived from the code, although this imposes certain limitations on the code. In Disel, high-level abstract protocol specifications are defined in terms of state-space coherence predicates and send/receive transitions.</p>
<p>The configuration of protocol components within nodes and their internal structure can be more static or dynamic. For example, in Babel, protocol components and various components' callbacks are registered within the runtime dynamically. The configuration of top-level components in Mir is rather static, for it cannot be changed after initialization, but there is a special component, called factory module, that supports creating sub-components dynamically. Such flexibility at runtime can make formal verification particularly hard, so the frameworks focused on formal verification (PSync, Disel, and Verdi) tend to be rather static with respect to the configuration and internal structure of protocol components.</p>
<p>Overall, the abstract model adopted by a framework, e.g. the model of a generic state transition system with message-passing or the Heard-Of model based on communication-closed rounds, largely determines how protocol specifications and implementations are structured within the framework. The framework's features like formal verification can add further restrictions, e.g. restricting runtime flexibility of the configuration and internal structure of protocol components.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="notation">Notation<a href="https://replica-io.dev/blog/2024/08/27/on-frameworks-for-implementing-distributed-protocols#notation" class="hash-link" aria-label="Direct link to Notation" title="Direct link to Notation">​</a></h2>
<p>All of the explored frameworks use the general-purpose programming language they are based on as the primary means for expressing protocol implementations. To enhance ergonomics and expressiveness, most of the frameworks introduce some notational extensions, e.g. elements of an embedded domain-specific language (eDSL).</p>
<p>Using a regular general-purpose programming language as the basis allows tapping directly into the comprehensive features of the language, such as the type system, polymorphism, inheritance, and metaprogramming. On the other hand, implementing protocol components in regular code can produce some undesirable effects such as nondeterminism, e.g. when iterating over built-in unordered data structures, which is problematic for reproducible simulation-based testing. For that reason, Mir provides some utility functions that should be used in place of usual idiomatic code to avoid that kind of nondeterminism. Rich expressiveness of general-purpose languages can also make automatic verification difficult, e.g. PSync is quite limited in what kind of Scala constructs it supports in automatic derivation of transition relations from the code.</p>
<p>In most cases, the notational extensions introduced by the frameworks serve to make the code more declarative and concise. One target of such enhancements is providing a convenient and clear way of expressing the typical event-oriented pseudo-code notation with <code>upon</code> statements. For example, the protocol logic in Distal is implemented by defining rules and the corresponding actions, whereby the rules are expressed in a declarative style resembling typical pseudo-code found in the literature and specify event predicates, such as the message type and matching conditions, as well as the means to specify composite events, which are triggered by collections of messages.</p>
<p>Another area of applying notational enhancements is for expressing certain actions performed by the protocol logic and overcoming the limitations of the host language. For example, Distal provides a special notation for sending messages, discarding received messages, as well as for scheduling actions to be executed in future. Disel extends Coq's specification language Gallina with effectful commands (actions), such as sending and receiving messages, reading from local state, monadic sequential composition, and general recursion. For message sending and receiving actions, Disel provides transition wrappers, which lift low-level operations on the networking layer to the level of well-typed program primitives corresponding to the protocol specification. Similarly, Verdi provides a monad for expressing the actions of sending messages, emitting output event, and manipulating the current state, as well as convenience notation for various monadic bindings.</p>
<p>Finally, expressing protocol properties, assumptions, and invariants, as well as the related annotations in the protocol implementation can also benefit from notational enhancements. PSync, for instance, defines a DSL for expressing properties, predicates and invariants, in which one of the main primitives is the notion of domain, representing a set of values of certain type with universal and existential quantification defined for it, as well as set comprehension. Disel features a special notation for representing the higher-order Hoare types of program fragments.</p>
<p>Many elements of a DSL can be implemented using common programming language techniques like polymorphism, inheritance, composition, higher-order functions, and the type system features. This way, Distal implements most of its DSL as ordinary methods and convenience aliases. However, this approach has certain limitations, and such techniques as metaprogramming (macros) or code generation are often required. For instance, in Distal, the key element of the DSL is implemented as a macro; in PSync, automatic derivation of transition relations from the code is also implemented as a macro. Code generation in Mir reduces the amount of hand-written boilerplate code by processing Protobuf definitions annotated with special extensions. Disel and Verdi take advantage of Coq's syntax extension features.</p>
<p>Clear and convenient notation for defining protocol specifications and their implementation is crucial for ergonomics and expressiveness. Building upon ordinary code, clever use of common programming language techniques, such as polymorphism, inheritance, composition, higher-order functions, and the type system features, should be the preferred approach for achieving notational expressiveness. Such techniques as metaprogramming and code generation can greatly help overcoming the limitations of that approach or further improving the notation, but they can make the framework more complicated and, therefore, should be employed judiciously.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="operation">Operation<a href="https://replica-io.dev/blog/2024/08/27/on-frameworks-for-implementing-distributed-protocols#operation" class="hash-link" aria-label="Direct link to Operation" title="Direct link to Operation">​</a></h2>
<p>In terms of operation, the core part in most of the frameworks is some kind of runtime or engine that orchestrates the execution of protocol components and their interaction. For concurrent execution of protocol components, the runtimes mostly rely on conventional concurrency mechanisms used in the corresponding language's ecosystem, such as goroutines in Go and execution pools in Java and Scala. Atlas, notably, is based on native OS threads rather than an async Rust runtime like Tokio, presumably due to a performance overhead of the latter.</p>
<p>There are two main approaches to implementing interaction based on message-passing between protocol components and with the networking layer: using a central event dispatching loop or through explicit channels established between components. Mir is a good example of the former approach, whereas Atlas follows the latter one. Since different protocol components normally operate asynchronously, there is often some kind of event queue or buffer placed between the components to accommodate for the asynchrony.</p>
<p>This raises an issue of preventing unbounded growth of those queues. Mir addresses this problem by temporarily blocking the influx of external events from active modules when the amount of events buffered in internal queues exceeds certain thresholds. Atlas relies on flow control provided by bounded buffered channels for communication between components.</p>
<p>In general, garbage collection issue is an important aspect of operation in distributed protocol implementations. Sometimes it can happen automatically, e.g. in PSync, received message sets are automatically discarded by the runtime upon transitioning into a new round. However, in some cases, it requires special care. For example, in Distal, protocol components should explicitly discard automatically buffered messages that become irrelevant for further execution of the protocol, in order to avoid unbounded growth of state and slowing down evaluation of rules. In Mir, there is an interesting pattern for performing garbage collection of internal component's state, whereby each disposable piece of state is assigned a numerical retention index, and the component removes the pieces of state whose retention index is below a specified value upon processing a dedicated garbage collection event emitted by another component.</p>
<p>Communication between nodes in most of the frameworks is implemented in a simplistic manner, providing best-effort message delivery, following the fire-and-forget communication style. Babel is a notable exception, since it introduces a notion of communication channel abstraction, where different channel types can represent different communication mechanisms with different properties and guarantees, e.g. more reliable message delivery, multiplexing connections, and φ-accrual failure detection.</p>
<p>So orchestrating the execution and coordinating interaction of protocol components often require some kind of runtime provided by the framework. The runtime should take care of asynchrony, garbage collection, communication, and coordination within the node, preventing unbounded growth of internal state and ensuring good performance.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="verification">Verification<a href="https://replica-io.dev/blog/2024/08/27/on-frameworks-for-implementing-distributed-protocols#verification" class="hash-link" aria-label="Direct link to Verification" title="Direct link to Verification">​</a></h2>
<p>Not all of the explored frameworks are concerned with verifying correctness of protocols and their implementations. Verification is the primary area of focus for Disel and Verdi, as well as PSync. Verification is not a major concern in Mir, though it provides some mechanisms that can be considered as lightweight verification of protocol implementation correctness.</p>
<p>Mir includes support for recording, inspecting, modifying, and replaying traces of events being passed by the node engine between the components, which can be very helpful for debugging, but also to perform correctness analysis. Mir also comes with a simple discrete-event simulation runtime that can be used for randomized reproducible testing with simulated time.</p>
<p>Full-fledged formal verification of protocol specifications and implementation in Disel and Verdi relies on machine-assisted theorem proving, whereas PSync attempts to automate the process. Theorem proving, even if machine-assisted, is a very difficult, time consuming task and requires special expertise. Automated verification, on the other hand, is in general undecidable and can only be achieved with certain restrictions to the system model and the protocol implementation.</p>
<p>Formal verification requires formal specification of the assumptions and the required properties. In Disel, protocol specifications are defined in terms of state-space coherence predicates and send/receive transitions. In Verdi, the correct behavior of the protocol is specified as a logical predicate over its possible traces of events. Formal specifications in PSync are expressed in terms of protocol properties, expressed in a fragment of a first-order temporal logic, as well as safety and liveness predicates (assumptions), expressed in terms of cardinalities of heard-of sets.</p>
<p>In these frameworks, the method of formally proving the correctness is typically by induction, constructing inductive state invariants. Coming up with appropriate inductive invariants constitutes the greatest difficulty in the verification effort and requires special skills.</p>
<p>In PSync, the simple round-based structure with lock-step semantics makes protocol implementation amenable to automated verification that can check safety and liveness properties. The verification, though, requires inductive invariants at the boundaries between rounds. However, the automated verification problem is decidable with certain constraints.</p>
<p>The correctness of protocol implementation in Verdi is proved directly, whereas Disel employs a different approach. For implementing protocol specification, Disel provides a DSL, embedded shallowly into Coq, that extends Coq's specification language Gallina. Disel programs and their fragments are assigned types corresponding to the protocol specification in higher-order separation-style Hoare logic. For message sending and receiving actions, Disel provides transition wrappers, which lift low-level operations on the networking layer to the level of well-typed program primitives corresponding to the protocol specification. Well-typed programs are guaranteed to be <em>correct by construction</em> w.r.t. the protocol specifications.</p>
<p>In Verdi, once the protocol is specified, implemented, and verified in an idealistic reliable network semantics, it can be translated using <em>verified system transformers</em> into an equivalent implementation, preserving the transformed system properties under a weaker fault model.</p>
<p>in Disel, protocol specifications can be generic and parameterized. The generic protocol specifications with their proven invariants can be used in composition. Disel provides mechanisms to establish stronger properties of generic protocols and their combinations by elaborating the protocol, i.e. strengthening it with additional inductive invariants.</p>
<p>Correctness is very important for the critical fault-tolerant protocols; therefore, the verification aspect deserves special attention. There are relatively easy-to-apply lightweight methods, such as randomized reproducible testing with discrete-event simulation, and there are sophisticated formal methods typically requiring special skills and expertise, such as machine-assisted theorem proving. However, some particularly structured system models may enable automated reasoning and make formal verification more practical, though at the cost of additional limitations.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusions">Conclusions<a href="https://replica-io.dev/blog/2024/08/27/on-frameworks-for-implementing-distributed-protocols#conclusions" class="hash-link" aria-label="Direct link to Conclusions" title="Direct link to Conclusions">​</a></h2>
<p>Having explored these 7 frameworks for implementing distributed protocols, I found most of them not sufficiently developed for practical use, though some of the ideas and techniques employed there were worth exploring. Being purely academic efforts, most of the frameworks seem to have been abandoned after exploring some ideas and publishing the results. As of time of this writing, Mir is perhaps the most mature, well documented, and up-to-date one among these frameworks.</p>
<p>Focusing on some particular aspects of implementing distributed protocols, such as unifying and standardizing components, testing and debugging, notational convenience, or formal verification, while mostly neglecting the remaining aspects, may be appropriate for academic research, but this is certainly not sufficient for achieving practical adoption. Moreover, the programming languages that most of the frameworks are based on would make it hard to integrate the protocol implementations directly into larger code bases written in other languages, let alone that having to learn a less commonly used language like Scala or Coq is an additional obstacle for adoption. Please refer to the <a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols" target="_blank" rel="noopener noreferrer">previous post</a> about practical aspects of implementing distributed protocols.</p>
<p>Most important, perhaps, is that all of the frameworks seem to basically adopt the same model of a state transition system and trying to mimic the event-oriented notation as found in typical pseudo-code with <code>upon</code> statements in the literature on distributed protocols. This largely impacts how protocol implementations are expressed and structured in those frameworks.</p>
<p>I believe, if we want to make a real breakthrough in <em>both designing and implementing</em> distributed protocols, which is what the Replica_IO project is about, then we should first of all be innovative, challenging the status quo, and think holistically, taking into account all relevant aspects. Trying to rethink the conventional distributed system model and the way of expressing distributed protocols would be a good start.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="next-steps">Next Steps<a href="https://replica-io.dev/blog/2024/08/27/on-frameworks-for-implementing-distributed-protocols#next-steps" class="hash-link" aria-label="Direct link to Next Steps" title="Direct link to Next Steps">​</a></h2>
<p>Having explored some distributed protocol implementations and frameworks for implementing distributed protocols, now it is a good time to clearly state the problems in designing and implementing distributed protocols to focus on for the rest of milestone <a href="https://github.com/replica-io/replica-io/milestone/1" target="_blank" rel="noopener noreferrer">M0.1</a> and start gathering ideas on how we could approach them. Apart from that, there are still some potentially related concepts, approaches, and techniques worth looking into as part of the initial state-of-the-art exploration. The exploration tasks are tracked in the scope of <a href="https://github.com/replica-io/replica-io/issues/7" target="_blank" rel="noopener noreferrer">this issue</a> on GitHub.</p>
<p>Once the initial exploratory stage is over, it will be time to come up with key ideas concerning core principles that will guide the process of designing and implementing generic components within the framework (milestone <a href="https://github.com/replica-io/replica-io/milestone/1" target="_blank" rel="noopener noreferrer">M0.1</a>). Then those ideas will be developed into clearly formulated concepts (milestone&nbsp;<a href="https://github.com/replica-io/replica-io/milestone/2" target="_blank" rel="noopener noreferrer">M0.2</a>), their feasibility will be verified with code (milestone&nbsp;<a href="https://github.com/replica-io/replica-io/milestone/3" target="_blank" rel="noopener noreferrer">M0.3</a>). After that, prototype, MVP, and production versions of the framework will be developed and released (milestones&nbsp;<a href="https://github.com/replica-io/replica-io/milestone/4" target="_blank" rel="noopener noreferrer">M1</a>, <a href="https://github.com/replica-io/replica-io/milestone/5" target="_blank" rel="noopener noreferrer">M2</a>, and <a href="https://github.com/replica-io/replica-io/milestone/6" target="_blank" rel="noopener noreferrer">M3</a>).</p>
<p>It does not mean at all that exploration, ideation, and prototyping will not take place at later stages; the milestones simply define the framework's general level of maturity. The framework will continuously evolve and expand and at some point become a de facto standard for implementing critical fault-tolerant systems providing a growing collection of easy-to-use reliable and efficient distributed replication mechanisms.</p>
<!-- -->
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37">❤️</span>Supporting</div><div class="admonitionContent_BuS1"><p>If you like the project and find it valuable, please <a href="https://github.com/sponsors/replica-io">support</a> its further development! 🙏</p></div></div>
<!-- -->
<section data-footnotes="true" class="footnotes"><h2 class="anchor anchorWithStickyNavbar_LWe7 sr-only" id="footnote-label">Footnotes<a href="https://replica-io.dev/blog/2024/08/27/on-frameworks-for-implementing-distributed-protocols#footnote-label" class="hash-link" aria-label="Direct link to Footnotes" title="Direct link to Footnotes">​</a></h2>
<ol>
<li id="user-content-fn-other-frameworks-ef0b52">
<p>If you know of some other framework for implementing distributed protocols that I should have looked into, please let me know. <a href="https://replica-io.dev/blog/2024/08/27/on-frameworks-for-implementing-distributed-protocols#user-content-fnref-other-frameworks-ef0b52" data-footnote-backref="" aria-label="Back to reference 1" class="data-footnote-backref">↩</a></p>
</li>
</ol>
</section>]]></content>
        <author>
            <name>Sergey Fedorov</name>
            <email>sergefdrv@replica-io.dev</email>
            <uri>https://github.com/sergefdrv</uri>
        </author>
        <category label="technical" term="technical"/>
        <category label="overview" term="overview"/>
        <category label="long" term="long"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[On Implementation of Distributed Protocols]]></title>
        <id>https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols</id>
        <link href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols"/>
        <updated>2024-03-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[A post concluding exploration of 14 notable distributed protocol implementations.]]></summary>
        <content type="html"><![CDATA[<p>This post concludes the first phase of the <a href="https://github.com/replica-io/replica-io/issues/7" target="_blank" rel="noopener noreferrer">state-of-the-art exploration</a> in the scope of milestone <a href="https://github.com/replica-io/replica-io/milestone/1" target="_blank" rel="noopener noreferrer">M0.1</a> of the Replica_IO project, namely exploration of selected notable distributed protocol implementations. It shares the main conclusions drawn from exploring 14 different code bases and outlines the key areas of focus for the next steps developing the Replica_IO framework.</p>
<!-- -->
<!-- -->
<div class="theme-admonition theme-admonition-note admonition_xJq3 alert alert--secondary"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</div><div class="admonitionContent_BuS1"><p>A companion video is available <a href="https://youtu.be/Q6wW8NqtpGw" target="_blank" rel="noopener noreferrer">here</a>.</p></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="exploring-distributed-protocol-implementations">Exploring Distributed Protocol Implementations<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#exploring-distributed-protocol-implementations" class="hash-link" aria-label="Direct link to Exploring Distributed Protocol Implementations" title="Direct link to Exploring Distributed Protocol Implementations">​</a></h2>
<p>I believe that discovering neat, yet practical, solutions to complicated problems demands serious, deliberate preparation. Clearly, before being able to come up with such solutions, one first needs to acquire a deep understanding of the problem, identify the relevant aspects and requirements. It is also important to learn from prior attempts to deal with the problem. Otherwise, it would be naive to expect any significant advancement beyond the status quo.</p>
<p>Since Replica_IO aims at making a breakthrough in designing and implementing distributed protocols, I decided to start exploring the state of the art by selecting and looking into a number of notable distributed protocol implementations. Although I already had experience implementing such protocols myself, nevertheless, I decided to dive in and see for myself how others had approached this challenge. I wanted to learn from those projects, better understand the typical requirements and difficulties coming up in real-world use cases, and, perhaps, discover some interesting techniques or ideas along the way, as well as to identify the key areas of focus for the next steps.</p>
<p>So I onboarded myself into one code base after the other, as if I were to work on it. I was focused on the general structure of code, node-to-node communication mechanisms, the implementation details of the core protocols ensuring consistency between nodes, as well as mechanisms for monitoring and controlling execution of the protocol. I tried my best to understand <em>how</em> those protocols are structured and implemented. After having explored each of the code bases, I summarized and shared some of my findings. You can find those overviews on <a href="https://github.com/replica-io/replica-io/wiki/State-of-the-art-exploration" target="_blank" rel="noopener noreferrer">this wiki page</a>.</p>
<p>Here is the full list of the code bases, written in different programming languages, that I explored<sup><a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#user-content-fn-other-impl-d8d72b" id="user-content-fnref-other-impl-d8d72b" data-footnote-ref="true" aria-describedby="footnote-label">1</a></sup>:</p>
<ol>
<li><a href="https://github.com/tendermint/tendermint" target="_blank" rel="noopener noreferrer">Tendermint Core</a> / <a href="https://github.com/cometbft/cometbft" target="_blank" rel="noopener noreferrer">CometBFT</a> — a state machine replication engine (written in Go);</li>
<li><a href="https://github.com/etcd-io/raft" target="_blank" rel="noopener noreferrer">etcd Raft</a> — a library for maintaining replicated state machines (written in Go);</li>
<li><a href="https://github.com/aptos-labs/aptos-core/tree/aptos-cli-v1.0.13/consensus" target="_blank" rel="noopener noreferrer">AptosBFT</a> — a consensus component supporting state machine replication in the Aptos blockchain (written in Rust);</li>
<li><a href="https://github.com/bft-smart/library" target="_blank" rel="noopener noreferrer">BFT-SMaRt</a> — a library implementing BFT-SMaRt, a state machine replication system (written in Java);</li>
<li><a href="https://github.com/SmartBFT-Go/consensus" target="_blank" rel="noopener noreferrer">SmartBFT-Go</a> — a library implementing state machine replication inspired by BFT-SMaRt (written in Go);</li>
<li><a href="https://github.com/paritytech/substrate" target="_blank" rel="noopener noreferrer">Substrate</a> — a framework for building application-specific blockchains (written in Rust);</li>
<li><a href="https://github.com/sigp/lighthouse" target="_blank" rel="noopener noreferrer">Lighthouse</a> — an Ethereum consensus client (written in Rust);</li>
<li><a href="https://github.com/algorand/go-algorand" target="_blank" rel="noopener noreferrer">Algorand</a> — a blockchain based on the Algorand consensus protocol (written in Go);</li>
<li><a href="https://github.com/ava-labs/avalanchego" target="_blank" rel="noopener noreferrer">Avalanche</a> — a blockchain platform based on the Avalanche consensus protocol (written in Go);</li>
<li><a href="https://github.com/dfinity/ic" target="_blank" rel="noopener noreferrer">Internet Computer blockchain</a> (ICP) — a general-purpose blockchain system developed by the DFINITY Foundation (written in Rust);</li>
<li><a href="https://github.com/MystenLabs/sui" target="_blank" rel="noopener noreferrer">Sui</a> — a smart contract platform based on Narwhal and Bullshark protocols (written in Rust);</li>
<li><a href="https://github.com/apache/zookeeper" target="_blank" rel="noopener noreferrer">Apache ZooKeeper</a> — a distributed coordination, synchronization, and configuration service (written in Java);</li>
<li><a href="https://github.com/apache/kafka" target="_blank" rel="noopener noreferrer">Apache Kafka</a> — a distributed event streaming platform implementing a variant of the Raft consensus protocol (written in Java, integrated with Scala);</li>
<li><a href="https://github.com/input-output-hk/cardano-node" target="_blank" rel="noopener noreferrer">Cardano</a> — a blockchain platform based on the Ouroboros family of consensus protocols (written in Haskell).</li>
</ol>
<p>In the subsequent sections, I will share with you some of the observations and conclusions I made while exploring those code bases. I decided to structure the discussion around the following aspects of implementing distributed protocols:</p>
<ul>
<li><em>complexity</em>: what makes distributed protocols hard to reason about and implement;</li>
<li><em>correctness</em>: how to ensure that the implementation guarantees the requires properties;</li>
<li><em>resource utilization</em>: how to prevent ineffective expenditure of limited computing resources;</li>
<li><em>maintainability</em>: how to manage long-running distributed systems and diagnose issues;</li>
<li><em>flexibility</em>: how to achieve high adaptability, reusability, and evolvability of code.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="complexity">Complexity<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#complexity" class="hash-link" aria-label="Direct link to Complexity" title="Direct link to Complexity">​</a></h2>
<p>Distributed, fault-tolerant protocols are notoriously hard to implement, and there are justifiable reasons for that. This is primarily because that kind of system consists of largely independent nodes communicating through potentially unstable, unreliable network; some of the nodes may fail in different ways. The protocol is required to tolerate, within a bound, such unfavorable conditions and keep working reliably. More than that, it is supposed to deliver decent performance using limited resources. All this adds a great deal of <em>inherent, essential complexity</em>, which we simply cannot remove without weakening our requirements.</p>
<p>However, when it comes to actually designing and implementing these protocols, there is also another kind of complexity: <em>incidental, non-essential complexity</em>. This kind of complexity, though being closely related, does not strictly belong to the problem. We incidentally introduce it because we are not aware of or fail to recognize a simpler way of solving the problem at hand.</p>
<p>Incidental complexity can start creeping in when trying to understand and interpret a protocol specification<sup><a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#user-content-fn-thinking-complexity-d8d72b" id="user-content-fnref-thinking-complexity-d8d72b" data-footnote-ref="true" aria-describedby="footnote-label">2</a></sup>, which is often too far from the realities of software engineering. Simply the way a protocol is specified can misguide the engineer trying to implement it and induce all sorts of difficulties. For example, pseudo-code in scientific papers is often defined in terms of global, unstructured variables and omits concurrency issues.</p>
<p>Implementing a distributed protocol in one of the conventional programming languages, chances are that the implementation will simply employ some general techniques commonly used in that language's ecosystem. Such general techniques may be very powerful and universal, but freely using this unconstrained power and flexibility, we can easily end up with a code base that is very hard to understand and maintain. For example, dealing with concurrency and synchronization using low-level primitives in the implementation of high-level protocol logic clutters the code and multiplies the complexity.</p>
<p>Haste is another great source of incidental complexity. There is always temptation to cut corners, especially when under time pressure. Imprudently copying approaches from elsewhere, adding temporary workarounds and ad hoc patches makes code entangled and poorly structured.</p>
<p>Using advanced features and sophisticated techniques can also add unnecessary complexity. Though this is ambivalent because it can actually help to express the implementation more conveniently and simplify the reasoning about it, but only when the advanced machinery is hidden behind a simple, clear, and easy to use interface.</p>
<p>It is pretty clear that introducing additional complexity is generally bad. But does it really matter? Couldn't we just implement the thing somehow, test it well, and simply tolerate the additional complexity? Well, surely, with rigorous testing, we can be sufficiently confident that our implementation is correct. However, in that case, making a small change, e.g. applying a simple fix to address a major issue discovered later can reportedly<sup><a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#user-content-fn-tendermint-liveness-fix-d8d72b" id="user-content-fnref-tendermint-liveness-fix-d8d72b" data-footnote-ref="true" aria-describedby="footnote-label">3</a></sup> take months of work. So it would be very hard to further improve, adapt, or reuse such implementation.</p>
<p>We need a structured, yet flexible enough, approach guiding us away from incidental complexity if we wish to avoid wasted efforts and foster innovation in the field. Let's look into more details concerning complexity in implementation of distributed protocols.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="modularity">Modularity<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#modularity" class="hash-link" aria-label="Direct link to Modularity" title="Direct link to Modularity">​</a></h3>
<p>We can deal with a complex problem, such as implementing a distributed protocol, by dividing it into smaller, simpler problems, solving them individually, and then combining the solutions to finally address the original problem. This is, basically, what modularity is about. In this process, it is crucial how we divide the problem, what kind of pieces we get, and how we combine them back together.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="granularity">Granularity<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#granularity" class="hash-link" aria-label="Direct link to Granularity" title="Direct link to Granularity">​</a></h4>
<p>First of all, modularity comes in different levels of <em>granularity</em>. Implementing a large component, such as a state machine replication engine, we can define its external dependencies, then split the component into several chunks of functionality and stop there. That is certainly better than having to deal with a complete monolith, but this level of modularity would still be too <em>coarse</em>. Instead, we can continue decomposing the sub-components further until we end up with reasonably small and simple, yet non-trivial, components; this is <em>fine</em> modularity.</p>
<p>All of the explored code bases exhibit some level of modularity. It is quite common to separate concerns by delegating pieces of functionality to external components. This way, most of the code bases clearly separate implementation of the protocol logic from such functionality as communication between nodes, producing and verifying cryptographic signatures, persistent storage, executing transactions on the replicated state, etc. Most of the implementations also separate dispatching of events, such as inbound messages, from their handling; there is typically a component responsible for classifying events and a number of components responsible for handling specific event types. Quite often there are separate components implementing the protocol logic specific to different roles that a node can play, e.g. leader and follower, or modes of operation, e.g. synchronization and normal operation. It is also common to separate different logical stages of the protocol, e.g. creating a proposal, validating a proposal, finalizing the decision. Another common pattern is to have a separate class of component responsible for maintaining state for each of the remote peers the node communicates with.</p>
<p>Some implementations go further and introduce smaller components, e.g. encapsulating the state of each individual proposal or representing the logic of counting votes and determining if there is a sufficient quorum. Nevertheless, there still remain components that are too complicated and hard to follow, so this modularity cannot be considered fine. To combat complexity, we need to learn how to achieve fine modularity.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="decomposition">Decomposition<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#decomposition" class="hash-link" aria-label="Direct link to Decomposition" title="Direct link to Decomposition">​</a></h4>
<p>As one can cut bricks at different angles, so one can decompose components into sub-components in different ways. One way is to focus on the <em>operational</em> aspects, i.e. on how the pieces of implementation are going to be executed. With this approach, components would be primarily organized around actual data and control flow. This has a profound effect on the structure of the implementation.</p>
<p>Focusing on the operational aspects, protocol implementations will tend to be represented as stateful components, or as collections of stateful components, reacting to external events. This naturally induces applying the object-oriented approach to structuring the whole implementation, in which the protocol logic is mostly expressed as modifying pieces of component's state in response to <em>individual</em> inbound events and optionally producing new outbound events.</p>
<p>Although pieces of functionality tend to imply some state, individual events in a distributed system mostly happen as logical consequences of some other, causally related events in the scope of a larger <em>distributed</em> process. Thus structuring the implementation around event handling might <em>not</em> help to clearly express the overall protocol logic.</p>
<p>The way we approach decomposition also greatly impacts such properties of code as <a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)" target="_blank" rel="noopener noreferrer"><em>coupling</em></a> and <a href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)" target="_blank" rel="noopener noreferrer"><em>cohesion</em></a>, i.e. the degree of interdependence between different components and the strength of relationship between the elements inside components, respectively. Loose coupling and high cohesion are generally desirable.</p>
<p>Failing to recognize the significance of implicit logical connections and properly express them often causes higher degree of coupling between components, i.e. entanglement. It is particularly important to distinguish essential and incidental complexity here. Sometimes complications, such as <em>circular dependencies</em>, may occur naturally and represent essential features of the protocol logic, e.g. <em>recursiveness</em>. For example, some internal events should often be treated, for the most part, the same way as equivalent external events. This can be achieved by looping those events back for handling in the protocol implementation.</p>
<p>Organizing components in a more structured way helps to manage dependencies between them, e.g. they can be arranged in <em>layers</em> or <em>hierarchically</em>, chained together in <em>pipelines</em>, etc. For example, in the Algorand implementation, the core logic of the consensus protocol is structured as a hierarchical state machine. The layered approach is well exemplified in the  <a href="https://docs.rs/tower/0.4.12/tower/" target="_blank" rel="noopener noreferrer"><code>tower</code></a>&nbsp;networking library, which is used by the Sui implementation. In the Apache ZooKeeper implementation, client requests are processed using a pipeline of&nbsp;request processing components chained together.</p>
<p>The amount of mutable internal state maintained by components also matters. Making components more static can often help to simplify the implementation. For example, in the Sui implementation, most of the consensus-specific components are static in terms of consensus configuration, i.e. instead of supporting reconfiguration directly in those components, they are simply recreated upon reconfiguration.</p>
<p>Many components require certain <em>context</em> or <em>environment</em>, i.e. they depend on some common piece of state or functionality like information about prior communication with the remote peer, access to persistent storage, diagnostic logging, etc. This is usually accomplished by capturing references to the environment inside the component or passing it explicitly. In functional programming, one can represent the environment with a <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)" target="_blank" rel="noopener noreferrer">monadic</a> interface. Some programming languages provide special features for that purpose, e.g. <a href="https://docs.scala-lang.org/tour/implicit-parameters.html" target="_blank" rel="noopener noreferrer">contextual parameters in Scala</a>. Interacting with the context from withing a component should be convenient but clearly constrained by the component's interface.</p>
<p>We would like to possibly avoid <em>fragmentation</em> of the core logic and facilitate <em>local reasoning</em> so that it is easier to reason about correctness, especially when introducing changes, without being too much concerned about larger scopes. We need to shift the focus more onto the <em>functional</em> and <em>logical</em> aspects, i.e. what the pieces of implementation achieve and how they ensure the desired outcome, so that the protocol implementation better reflects causal dependencies and logical connections.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="composability">Composability<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#composability" class="hash-link" aria-label="Direct link to Composability" title="Direct link to Composability">​</a></h4>
<p>Even a highly modular implementation is not necessarily highly <a href="https://en.wikipedia.org/wiki/Composability" target="_blank" rel="noopener noreferrer"><em>composable</em></a>, i.e. allowing to easily recombine and reuse its components. It is hard to reuse components that are not composable. Moreover, composability has huge transformative potential: unlocking true power of expressiveness and flexibility, we can push the limits and uncover a new dimension of possibilities for finding better solutions, whether to fix a flaw in an existing implementation or to design and implement something completely new.</p>
<p>Composability primarily emerges from the properties of individual components and the way they can be combined together. It demands components that are not only loosely coupled, but <em>generic</em> as well. It also requires <em>unified</em> means of abstraction and combination that satisfy certain properties, such as <a href="https://en.wikipedia.org/wiki/Closure_(mathematics)" target="_blank" rel="noopener noreferrer">closure</a> and <a href="https://en.wikipedia.org/wiki/Associative_property" target="_blank" rel="noopener noreferrer">associativity</a>, while preserving principal properties of individual components in combination.</p>
<p>All of the explored code bases were meant to implement only a specific protocol or a close family of protocols, except Substrate, which is supposed to support a wide range of protocols. Most of the implementations define abstract interfaces for major components, employing various forms of <a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" target="_blank" rel="noopener noreferrer">polymorphism</a>, and apply the <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" target="_blank" rel="noopener noreferrer">dependency inversion principle</a>. This makes components replacable and can help to reduce coupling. Being able to replace a component allows using alternative implementations of the component, e.g. for unit testing. However, most of those dependency inversion interfaces seem to only make sense within a very specific, predefined structure of the whole implementation, i.e. they are mostly about decomposing rather than recomposing. Truly composable components, on the other hand, are those that can be put together in an open-ended range of new, surprising combinations.</p>
<p>Though there are some examples of composability used in the explored code bases. The communication layer in the Sui implementation takes advantage of the layered design of &nbsp;<a href="https://github.com/MystenLabs/anemo" target="_blank" rel="noopener noreferrer"><code>anemo</code></a>, a peer-to-peer networking library based on <a href="https://docs.rs/tower/0.4.12/tower/" target="_blank" rel="noopener noreferrer"><code>tower</code></a>: it processes RPC requests from other nodes through pipelines composed out of&nbsp;<code>tower</code>&nbsp;middleware layers provided by the&nbsp;<code>anemo</code>&nbsp;library. The state machine representing the core logic of the consensus protocol in the Algorand implementation consists of uniformly defined event handlers organized in a hierarchy of event routers dispatching events to the corresponding handler.</p>
<p><a href="https://en.wikipedia.org/wiki/Asynchrony_(computer_programming)" target="_blank" rel="noopener noreferrer">Asynchrony</a> and <a href="https://en.wikipedia.org/wiki/Concurrency_(computer_science)" target="_blank" rel="noopener noreferrer">concurrency</a> make achieving composability particularly challenging. Components implemented using usual concurrent programming techniques based on <a href="https://en.wikipedia.org/wiki/Lock_(computer_science)" target="_blank" rel="noopener noreferrer">lock-based</a> synchronization primitives fall short of composability: a simple combination of individually absolutely correct components may easily fail to ensure consistency or cause a deadlock. Ensuring correctness in this model often requires breaking abstractions and dealing with synchronization directly in an awkward and error-prone way. Alternative concurrent programming techniques, such as <a href="https://en.wikipedia.org/wiki/Software_transactional_memory" target="_blank" rel="noopener noreferrer">software transactional memory</a> (STM) used in the Cardano implementation, can help to overcome these issues without compromising on modularity and composability. More on asynchrony and concurrency in the next section.</p>
<p>Functional programming places a significant emphasis on composability. One of its core principles is to break down programs into smaller, reusable functions, avoiding side effects, that can be easily combined to create more complex functionality. This encourages a more <em>declarative notation</em>, which often results in code that is easier to reason about. The approaches and techniques employed in functional programming, such as <a href="https://en.wikipedia.org/wiki/Immutable_object" target="_blank" rel="noopener noreferrer">immutability</a>, <a href="https://en.wikipedia.org/wiki/Lazy_evaluation" target="_blank" rel="noopener noreferrer">lazy evaluation</a>, <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)" target="_blank" rel="noopener noreferrer">monads</a> and <a href="https://en.wikipedia.org/wiki/Effect_system" target="_blank" rel="noopener noreferrer">effect systems</a>, etc., are therefore a great source of ideas for enhancing composability.</p>
<p>Composability is indispensable for <em>future-proof</em> software solutions. Though this property doesn't necessarily emerge together with modularity; conversely, achieving it may be challenging, especially in the inherently concurrent context of distributed systems. Therefore, we should approach this proactively and deliberately design for composability.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="concurrency">Concurrency<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#concurrency" class="hash-link" aria-label="Direct link to Concurrency" title="Direct link to Concurrency">​</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Concurrent_computing" target="_blank" rel="noopener noreferrer">Concurrent programming</a> is a way to structure code into multiple <em>threads of control</em>—concurrent tasks—that can execute concurrently. Observable effects caused by individual tasks can interleave in concurrent execution. Understanding and reasoning about code in concurrent programming requires a more complex mental model compared to sequential programming. Perhaps, <em>nondeterminism</em> is the main source of complexity in concurrent programming: concurrent programs can produce different results depending on the exact timing of external events and task execution.</p>
<p>Concurrent programming is known to be error prone. Concurrent tasks accessing shared resources generally require some form of coordination. Depending on the available mechanisms for interaction and communication between concurrent tasks, there may be different methods of coordinating them and controlling concurrency, e.g. <a href="https://en.wikipedia.org/wiki/Lock_(computer_science)" target="_blank" rel="noopener noreferrer">lock-based synchronization primitives</a>, <a href="https://en.wikipedia.org/wiki/Message_passing" target="_blank" rel="noopener noreferrer">message passing</a>, and <a href="https://en.wikipedia.org/wiki/Software_transactional_memory" target="_blank" rel="noopener noreferrer">software transactional memory</a>. However, properly applying those methods in a nontrivial system often becomes complicated and requires great deal of care. When concurrent tasks happen to <em>interfere</em> with each other in unanticipated ways, subtle issues, such as&nbsp;<a href="https://en.wikipedia.org/wiki/Race_condition#In_software" target="_blank" rel="noopener noreferrer">race conditions</a>,&nbsp;<a href="https://en.wikipedia.org/wiki/Deadlock" target="_blank" rel="noopener noreferrer">deadlocks</a>, and&nbsp;<a href="https://en.wikipedia.org/wiki/Starvation_(computer_science)" target="_blank" rel="noopener noreferrer">resource starvation</a>, may start manifesting themselves.</p>
<p>Concurrent programs with mutable memory shared between threads can suffer from <a href="https://en.wikipedia.org/wiki/Race_condition#Data_race" target="_blank" rel="noopener noreferrer"><em>data races</em></a>. A data race is basically a situation where one thread accesses a memory location whereas another thread can simultaneously perform a conflicting write to that memory location. Preventing data races is not only important to avoid memory corruption; this can also significantly simplify the mental model.</p>
<p>Normally, we can assume <a href="https://en.wikipedia.org/wiki/Sequential_consistency" target="_blank" rel="noopener noreferrer">sequential consistency</a> in concurrent programs that are free of data races. In essence, a sequentially consistent execution of a concurrent program must be equivalent to <em>some</em> <em>sequential</em> execution, respecting the order and semantics of operations specified in the program. So such executions are linear schedules, each representing a possible concurrent interleaving of the program.</p>
<p>Execution schedules that only differ in the interleaving of operations local to threads of execution, i.e. operations not visible to other threads or externally, are effectively equivalent. Therefore, the number of possible distinct schedules depends on the number of <em>non-local</em> operations in the execution, i.e. operations used to communicate between threads or cause externally visible effects, and it grows exponentially.</p>
<p>Concurrent programming is an effective model of computation, but it is more complex and requires an appropriate approach in order to avoid subtle concurrency issues. Data face freedom is a particularly desired property since it simplifies the model providing sequential consistency. Under that model, reducing the number of non-local operations can greatly help to further simplify reasoning about the concurrent program.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="approaches-to-concurrency">Approaches to Concurrency<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#approaches-to-concurrency" class="hash-link" aria-label="Direct link to Approaches to Concurrency" title="Direct link to Approaches to Concurrency">​</a></h4>
<p>Programming languages support different approaches to concurrency; they provide different features and different concurrency mechanisms in their runtimes and ecosystems. The explored code bases are written in the following languages: Java, Go, Rust, and Haskell. Let's have a look at how those code bases approach concurrency, depending on the choice of programming language.</p>
<p>The code bases written in traditional mainstream languages like Java tend to achieve concurrency by explicitly spawning <a href="https://en.wikipedia.org/wiki/Thread_(computing)#Kernel_threads" target="_blank" rel="noopener noreferrer"><em>OS threads</em></a>, which communicate through <em>shared mutable memory</em> and synchronize with <a href="https://en.wikipedia.org/wiki/Lock_(computer_science)" target="_blank" rel="noopener noreferrer"><em>lock-based primitives</em></a>. Those implementations are normally structured into objects exposing thread-safe methods to interact with them concurrently. This approach is well known and established in the industry; it is therefore <em>widely supported</em> in the ecosystems built around those languages. Newer system programming languages like Rust usually provide support for this approach, as well.</p>
<p>This low-level approach gives the programmer a <em>high level of control</em> as it directly reflects how concurrency is actually achieved by the system. On the other hand, it requires a lot of care since properly using low-level synchronization primitives together is tricky and <em>error prone</em>. Moreover, OS threads are relatively <em>expensive</em>, and, therefore, building highly concurrent programs by frequently spawning short-living threads on demand is impractical. Instead, programs are often organized into a small number of long-running threads; though using thread pools can help to achieve more flexibility. Most importantly, as mentioned before, concurrent components synchronized with the lock-based primitives suffer from <em>poor composability</em>.</p>
<p>The Go language has built-in support for concurrency based on <a href="https://en.wikipedia.org/wiki/Computer_multitasking#Preemptive_multitasking" target="_blank" rel="noopener noreferrer">preemptive multitasking</a> with lightweight <a href="https://en.wikipedia.org/wiki/Thread_(computing)#User_threads" target="_blank" rel="noopener noreferrer">user threads</a> called <em>goroutines</em>. It encourages <em>message-passing</em> style of communication and synchronization between goroutines through blocking, optionally buffered FIFO <em>channels</em>; though it also supports traditional lock-based synchronization. The built-in <a href="https://go.dev/ref/spec#Select_statements" target="_blank" rel="noopener noreferrer"><code>select</code> statement</a> can be used to combine several channel operations in order to perform a single pseudo-randomly selected operation that is ready to proceed; unless there is a default case, the <code>select</code> statement blocks until at least one of the operations can proceed.</p>
<p>The <code>select</code> statement in Go allows <em>composing</em> multiple potentially blocking operations on channels into a single operation. For that reason, some of the explored code bases, e.g. SmartBFT-Go, occasionally use Go channels in place of traditional lock-based synchronization primitives in order to combine them with channel operations in a single <code>select</code> statement.</p>
<p>Go does not restrict access to <em>shared mutable data</em> by concurrent goroutines, so <em>data races</em> are still possible. Go provides quite <em>limited control</em> over the runtime managing execution of goroutines, thus making fine-tuning and controlling concurrent execution difficult.</p>
<p>The Rust language emphasizes safety without sacrificing performance. Thanks to the <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html" target="_blank" rel="noopener noreferrer">ownership model</a> and strong type system, it can effectively ensure at compile time that the code is <em>free of data races</em>. Being a system programming language, Rust supports concurrent programming with OS threads and shared memory, which are useful to optimize performance and for implementing other styles of concurrency, such as message passing. Rust's ownership and type system features prevent accidental sharing of mutable state between threads.</p>
<p>The explored code bases written in Rust primarily rely on the <a href="https://en.wikipedia.org/wiki/Asynchrony_(computer_programming)" target="_blank" rel="noopener noreferrer">asynchronous</a> programming features of Rust to achieve concurrency. Async Rust can be seen as a form of <a href="https://en.wikipedia.org/wiki/Cooperative_multitasking" target="_blank" rel="noopener noreferrer">cooperative multitasking</a> where asynchronous, non-blocking computations are represented with the <a href="https://docs.rs/futures/latest/futures/future/trait.Future.html" target="_blank" rel="noopener noreferrer"><code>Future</code></a> trait (interface). Rust futures are <em>passive</em>, i.e. they have to be actively driven by <em>polling</em> in order to make progress.</p>
<p>Ultimately, asynchronous code in Rust requires some <em>executor</em> function that can drive a future by polling it to completion. There is an open-ended <em>choice of async runtimes</em> in the Rust ecosystem, which provide executors. <a href="https://tokio.rs/" target="_blank" rel="noopener noreferrer">Tokio</a> is one of the most widely used runtimes in the Rust ecosystem; all of the explored code bases written in Rust are based on it. One can create <em>specialized runtimes</em>, e.g. Sui has a simulator that provides an drop-in replacement for Tokio and supports deterministic, randomized execution.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Async/await" target="_blank" rel="noopener noreferrer">async/await syntax</a> in Rust helps writing asynchronous fragments of code very close to normal, synchronous code. The <code>async</code> keyword introduces an <em>async context</em> by constructing a future from the corresponding piece of code; the <code>await</code> expression can be used within an async context to poll another future and yield control if that future is not yet ready to produce a value.</p>
<p>Apart from using the async/await syntax, Rust futures can be <em>composed</em> together using various combinators provided by the <a href="https://docs.rs/futures/latest/futures/" target="_blank" rel="noopener noreferrer"><code>futures</code></a>, <a href="https://docs.rs/tokio/latest/tokio/" target="_blank" rel="noopener noreferrer"><code>tokio</code></a>, and other crates. In particular, the <code>select</code> macro allows polling multiple futures simultaneously until one of them completes, similar to the <code>select</code> statement in Go; the&nbsp;<code>join</code>&nbsp;macro polls multiple futures to completion. There are also asynchronous channels for asynchronously producing a sequence of values and streams for communication between asynchronous tasks.</p>
<p>Asynchronous Rust is evolving rapidly; thus, it may still lack maturity, has limited documentation and less-established best practices. Many developers find programming in asynchronous Rust quite challenging and sometimes counter-intuitive, e.g. when dealing with cancellation, long-running or blocking operations, and due to the passive nature of futures. Although Rust prevents some concurrency problems like data races, concurrent code is still vulnerable to different types of concurrency bugs (e.g., deadlocks, logic errors, etc.) and requires deep understanding and careful design.</p>
<p>Finally, concurrency in Haskell is based on lightweight <a href="https://en.wikipedia.org/wiki/Thread_(computing)#User_threads" target="_blank" rel="noopener noreferrer">user threads</a>. Haskell allows throwing asynchronous exceptions from one thread to another. Handling asynchronous exceptions safely requires great care in <a href="https://en.wikipedia.org/wiki/Critical_section" target="_blank" rel="noopener noreferrer">critical sections</a>, i.e. when manipulating shared resources. Since Haskell is a <a href="https://en.wikipedia.org/wiki/Purely_functional_programming" target="_blank" rel="noopener noreferrer">purely functional</a> programming language, it does not explicitly support shared mutable memory for communication between threads. One of the mechanisms for normal communication between Haskell threads is <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Control-Concurrent-MVar.html" target="_blank" rel="noopener noreferrer"><code>MVar</code></a>, a synchronizing variable, which can act as a synchronized container for shared state or as a one-place channel. Concurrent Haskell <em>prevents data races</em>, but using <code>MVar</code>s is susceptible to other concurrency bugs, such as race conditions, deadlocks, etc.</p>
<p>Another mechanism for concurrent communication widely used in the Haskell ecosystem is <a href="https://en.wikipedia.org/wiki/Software_transactional_memory" target="_blank" rel="noopener noreferrer">Software Transactional Memory</a> (STM). STM is an <a href="https://en.wikipedia.org/wiki/Optimistic_concurrency_control" target="_blank" rel="noopener noreferrer">optimistic concurrency</a> mechanism that allows transactions over shared mutable variables (transactional variables or&nbsp;<a href="https://hackage.haskell.org/package/stm-2.5.2.1/docs/Control-Concurrent-STM-TVar.html" target="_blank" rel="noopener noreferrer"><code>TVar</code></a>s) to be <em>safely composed</em> and&nbsp;<a href="https://hackage.haskell.org/package/stm-2.5.2.1/docs/Control-Monad-STM.html#v:atomically" target="_blank" rel="noopener noreferrer">atomically executed</a>, without exposing the implementation details. STM transactions can&nbsp;<a href="https://hackage.haskell.org/package/stm-2.5.2.1/docs/Control-Monad-STM.html#v:retry" target="_blank" rel="noopener noreferrer">block</a>&nbsp;on an <em>arbitrary</em> condition; alternative STM transactions can be composed together using the&nbsp;<a href="https://hackage.haskell.org/package/stm-2.5.2.1/docs/Control-Monad-STM.html#v:orElse" target="_blank" rel="noopener noreferrer"><code>orElse</code></a>&nbsp;combinator. The Haskell type system ensure that STM transactions cannot have undesired side effects and thus are safe to roll back and retry.</p>
<p>Building various custom concurrency abstractions and combinators with STM is relatively easy and safe, thanks to <em>high composability</em>. For instance, in Cardano, concurrent components expose STM transactions for retrieving relevant pieces of their mutable current state; the components then interact by combining and atomically executing such STM queries from other components and atomically updating the corresponding pieces of their own mutable state.<sup><a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#user-content-fn-modular-concurrency-with-stm-d8d72b" id="user-content-fnref-modular-concurrency-with-stm-d8d72b" data-footnote-ref="true" aria-describedby="footnote-label">4</a></sup></p>
<p>However, STM has some limitations and caveats. First of all, <em>composable</em> <em>multi-way</em> communication between threads cannot be expressed in STM. That is because STM transactions cannot produce a visible side effect while being blocked. This is closely related to another limitation: STM does not provide <em>fairness</em> for threads waiting in a blocked STM transaction. In contrast, <code>MVar</code>s guarantee fair scheduling of threads blocked on the same <code>MVar</code>. STM also incurs some overhead in terms of memory and performance costs, which depends on the size of transactions. Though sometimes it can actually help building more efficient mechanisms. Long-running STM transactions can suffer from starvation, i.e. being repeatedly rolled-back and retried. Finally, Haskell, similar to Go, provides quite limited control over its runtime.</p>
<p>To summarize, the traditional mainstream approach to concurrency based on explicit, low-level synchronization primitives and communication directly through shared mutable memory is well known and established, but it is tricky, error prone, and suffers from poor composability. Restricting concurrent access to shared memory, e.g. with the ownership model as in Rust or immutability as in Haskell, can help preventing data races. Communication and synchronization through message passing primitives like channels and using combinators like select can improve composability. Spawning short-lived OS threads may be too expensive; thread pools and lightweight user thread runtimes can help to achieve more flexibility. Though relying on a concurrency runtime is an additional dependency that is not always replacable or adjustable. Another approach to concurrency with good flexibility and composability is asynchronous programming with cooperative multitasking and async/await syntax, as exemplified by Rust. Software transactional memory is a highly composable and flexible approach to concurrency, though it has some restrictions, additional overhead and does not guarantee fairness.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="evading-concurrency">Evading Concurrency<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#evading-concurrency" class="hash-link" aria-label="Direct link to Evading Concurrency" title="Direct link to Evading Concurrency">​</a></h4>
<p>Given all the challenges with concurrent programming, why not trying to avoid concurrency as much as possible? Some of the explored code bases go quite far this route and implement almost all of the core protocol logic as a <em>completely sequential state machine</em>, perhaps only offloading long-running operations (e.g., computationally intensive cryptography) to dedicated concurrent execution pools. Let's consider consequences of this approach.</p>
<p>First of all, distributed systems are <em>inherently concurrent</em> because they, by definition, consist of multiple nodes running largely independently. Thus, each node needs to handle events (e.g., messages received over the network or expired timeouts) originating from different sources <em>asynchronously</em>, i.e. independent of its main program flow and handling of events from other sources. Moreover, the protocol logic must also reflect the concurrent nature of the system.</p>
<p>So some parts of the protocol are fundamentally sequential, e.g. delivering totally ordered transactions, whereas some parts are fundamentally concurrent, e.g. handling of messages received over the network from different peer nodes. Some parts <em>may</em> be concurrent, but don't have to, e.g. validation of the subsequent messages while finishing processing of the current one.</p>
<p>Attempting to implement an essentially concurrent part of the protocol in a sequential manner, i.e. without using concurrent programming techniques, necessarily requires explicitly maintaining and switching contexts. Not only this adds some amount of boilerplate code and makes it entangled, more importantly, this causes <em>fragmentation</em> of the core protocol logic because such an artificially sequential component still has to multiplex handling of asynchronous events. Therefore, what in concurrent programming could have been naturally expressed as a blocking operation becomes an abrupt return of control, breaking out of the sequential component.</p>
<p>There is another problem with multiplexed handling of asynchronous events in sequential code, namely controlling the flow of events from concurrent sources. Consider a situation where a sequential component is given an event to handle that it cannot yet fully process because, in order to make a decision on how to react to the event, it first needs to handle some other events, e.g. it has to complete the current round of the protocol before participating in a new one. Since the sequential component cannot block waiting and has to return the control back, there are basically two options: dropping the event or putting it aside into some kind of buffer. In the first case, the event source cannot assume that all events it emits will be reliably handled and has to take this into account in its logic, e.g. emit an equivalent event under some conditions later. In the second case, there should be some way to enforce a reasonable bound on the amount of buffered pending events without compromising the protocol properties, e.g. emitting further events only after having received an acknowledgement from the destination. This can add a lot more complexity to the protocol implementation.</p>
<p>So concurrency cannot be easily evaded in distributed systems. Attempting to avoid using concurrent programming techniques complicates the implementation and causes fragmentation of the protocol logic in code. On the other hand, when done appropriately, designing for concurrency and using concurrent programming techniques can actually be advantageous. It boils down to recognizing inherently concurrent and sequential parts of the protocol and finding appropriate ways to express this distinction in code. Those parts of the protocol that are neither inherently concurrent nor sequential may nevertheless benefit from being implemented as concurrent: Designing for concurrency can guide towards better decoupling of components while concurrent execution can help to achieve higher responsiveness and performance.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="nondeterminism">Nondeterminism<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#nondeterminism" class="hash-link" aria-label="Direct link to Nondeterminism" title="Direct link to Nondeterminism">​</a></h3>
<p>As mentioned in the previous section, distributed systems are inherently concurrent and therefore nondeterministic. If we think of nondeterminism in terms of events happening in the system then it can manifest itself as unpredictable events or their order. For example, requests from external agents (clients, users, etc.), values produced by a random-number generator, or node failures are not known in advance; the same set of messages may arrive at different nodes in different order due to unpredictable delays in communication; timeouts may happen due to unexpectedly long delays. Inner workings of nodes can introduce additional, implementation-specific nondeterminism, e.g. unspecified order of iteration over unordered collections, scheduling of concurrent tasks, etc. To some extend, the purpose of distributed protocols can be seen as confining nondeterminism within certain constraints in order to maintain the required invariants.</p>
<p>Nondeterministic steps in protocol execution introduce alternative state transitions, thus expanding the <a href="https://en.wikipedia.org/wiki/State_space_(computer_science)" target="_blank" rel="noopener noreferrer"><em>state space</em></a>. This complicates reasoning about distributed protocols, as well as implementing and verifying them, because it often requires considering a large number of possible executions. Nondeterministic execution also makes <em>reproducing</em> problems and debugging particularly challenging. Therefore, it is desirable to control nondeterminism or attempt to eliminate it.</p>
<p>Some of the explored code bases constrain nondeterminism by implementing parts of the protocol as <em>deterministic</em> state machines. Inherently nondeterministic aspects, such as time, randomness, and asynchronous operations, are abstracted out of those state machines. Randomness, as well as current time, can be supplied to the state machine through abstract interfaces provided as dependencies. Alternatively, the current timestamp can be supplied to the state machine at each step explicitly in the input. Time can also be represented in terms of an abstract logical clock maintained by the state machine, which is then advanced with special tick events periodically supplied to the state machine. Asynchronous operations can be requested by the state machine by emitting special output events; the result is then supplied back as special input events. This approach is very close to evading concurrency discussed before and therefore is associated with the same kind of disadvantages.</p>
<p>In Haskell, as a strictly typed purely functional programming language, ordinary functions are deterministic (<a href="https://en.wikipedia.org/wiki/Referential_transparency" target="_blank" rel="noopener noreferrer">referentially transparent</a>) in the mathematical sense: given the same input, they must produce the same result. Nondeterministic computations are expressed using the <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)" target="_blank" rel="noopener noreferrer">monadic</a> interface. Only IO actions, when executed in the&nbsp;<a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/GHC-IO.html#t:IO" target="_blank" rel="noopener noreferrer">IO monad</a>, can cause side effects and produce nondeterministic results. This is enforced by the type system. Cardano takes advantage of this by making most of its code polymorphic in the main IO-like monad. This allows fully controlling nondeterminism by choosing the main monad implementation.</p>
<p>Being able to control nondeterminism is particularly useful for testing and debugging. This allows creating <em>reproducible</em> test environments, as well as <a href="https://en.wikipedia.org/wiki/Discrete-event_simulation" target="_blank" rel="noopener noreferrer">discrete-event simulation</a>&nbsp;for faster-than-real-time simulation of time delays. For example, Cardano uses a simulation environment for the IO monad that closely follows core Haskell packages; Sui has a simulator based on&nbsp;<a href="https://github.com/madsim-rs/madsim" target="_blank" rel="noopener noreferrer"><code>madsim</code></a> that provides an API-compatible replacement for the&nbsp;<a href="https://tokio.rs/" target="_blank" rel="noopener noreferrer">Tokio</a> runtime and intercepts various POSIX API calls in order to enforce determinism. Both allow running the same code in production as in the simulator for testing.</p>
<p>Nondeterminism is an important aspect of distributed systems, so it should be clearly expressed in the implementation. Type system features can help with that. Confining nondeterminism within <em>natural</em> boundaries of components can reduce complexity and simplify reasoning about the protocol implementation. Simulated execution of unmodified code with controlled nondeterminism is a very effective technique in testing and debugging.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="communication">Communication<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#communication" class="hash-link" aria-label="Direct link to Communication" title="Direct link to Communication">​</a></h3>
<p>Communication is at the core of distributed systems where individual nodes need to coordinate in order to act as a coherent system. Nodes in a distributed system interact with each other by exchanging <em>peer-to-peer</em> (P2P) messages. The communication happens over an <em>unreliable</em> network medium that only provides <em>best-effort, unordered delivery</em> of data packets, i.e. it may fail to deliver individual packets or deliver them out of order. Moreover, nodes can fail, and, in general, it may be impossible to determine precisely if a peer node has failed or its messages were simply dropped or delayed in the network. Nodes can also differ in processing power and experience different traffic load. Therefore, it is important to manage the rate of data transmission using <a href="https://en.wikipedia.org/wiki/Flow_control_(data)" target="_blank" rel="noopener noreferrer"><em>flow control</em></a> mechanisms, as well as to retransmit lost pieces of data. This can contribute significantly to the overall complexity of distributed protocols and their implementation.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="communication-layers">Communication Layers<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#communication-layers" class="hash-link" aria-label="Direct link to Communication Layers" title="Direct link to Communication Layers">​</a></h4>
<p>Most of the explored implementations use SSL/TLS over TCP/IP as a transport layer for P2P communication. Establishing a TCP connection takes a few packet round trips over the network. Moreover, operating systems impose limits on the number of open TCP connections per process because they consume system resources. For those reasons, communication layers based on TCP establish long-lived connections with remote peers and try to keeps the number of open connections low. This often means that the transport-level connections have to be <em>multiplexed</em> into multiple logical sub-streams.</p>
<p>Substrate and Lighthouse use <a href="https://libp2p.io/" target="_blank" rel="noopener noreferrer"><code>libp2p</code></a> as a networking stack for communication between nodes. The <code>libp2p</code>  framework is a versatile modular peer-to-peer networking stack. It provides a collections of abstractions, mechanisms, and protocols for facilitating communication in P2P systems. In particular, <code>libp2p</code> supports multiple transport mechanisms (TCP, QUIC, WebSocket, WebTransport, etc.), encryption schemes (TLS and Noise), and stream multiplexing. Higher-level protocols in <code>libp2p</code> are implemented on top of reliable, ordered, bidirectional binary streams, which are transparently encrypted and multiplexed by the framework.</p>
<p>Communication layer in Sui is based on&nbsp;<a href="https://github.com/MystenLabs/anemo" target="_blank" rel="noopener noreferrer"><code>anemo</code></a>, a peer-to-peer networking library built on top of&nbsp;<a href="https://en.wikipedia.org/wiki/QUIC" target="_blank" rel="noopener noreferrer">QUIC</a>. QUIC is a modern higher-level network transport protocol layered over UDP. It has built-in support for encryption and multiplexing. Similar to TCP connections, QUIC streams are reliable, ordered, bidirectional, providing flow control (backpressure), but they are cheap and almost instantaneous to open once an initial connection is established. The <code>anemo</code> library takes advantage of the efficient stream-multiplexing capability of QUIC; <code>libp2p</code> also uses the built-in capabilities of QUIC when it is used as a transport mechanism.</p>
<p>So there may be several levels of communication abstractions. There are low-level transport protocols like UDP or TCP, medium-level ones like QUIC, and comprehensive high-level networking stacks like <code>libp2p</code>. Higher-level mechanisms can be built on top of lower-level layers. Sometimes, it makes sense to fuse several layers, e.g. QUIC efficiently embeds security into the transport layer. In order to simplify implementation of higher-level layers, it is desirable to take advantage of those properties that are already guaranteed by lower-level layers, e.g. reliable, ordered delivery and flow control provided by commonly used transport layers such as TCP and QUIC.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="styles-of-communication">Styles of Communication<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#styles-of-communication" class="hash-link" aria-label="Direct link to Styles of Communication" title="Direct link to Styles of Communication">​</a></h4>
<p>There are different ways to organize communication between nodes. The most common styles of communication in the explored code bases are <em>request-response</em> and <em>fire-and-forget</em> message delivery. The <em>request-response</em> style follows the remote procedure call (RPC) pattern: the initiator node sends a message to the remote node, and the latter is expected to respond back. In the fire-and-forget style, the initiator node unidirectionally sends messages to the remote node without waiting for a response. Another style of communication, which is also often used in the explored implementations, is <em>gossiping</em>, where nodes publish and disseminate pieces of information among themselves in an indirect and random manner. Cardano uses a <em>session-based</em> style of communication, where peers establish continuous bidirectional communication channels and exchange messages according to some stateful communication protocol.</p>
<p>The <em>fire-and-forget</em> message delivery is a very simple style of communication. It does not mandate any acknowledgement from the remote node, so it can only provide best-effort delivery guarantee. Messages that cannot be handled for any reason are often simply dropped, e.g. when a message queue is full. Usually, there is also no guarantee about ordering of messages. Higher-level code needs to take care of such things as flow control, retransmission of lost messages, as well as determining and maintaining the context to handle messages in. On the other hand, this style can be expressed with a non-blocking interface. That allows sending a message to a group of remote nodes at once, which is a simple form of best-effort multi-/broadcasting. Some implementations provide a blocking or asynchronous variant of the interface giving more control over data flow within the local node. For example, in Substrate, the sender should wait until it acquires a free slot in the outgoing message buffer; the slot reservation is then consumed to enqueue a message.</p>
<p>The <em>request-response</em> style is a simple type of session-based communication: sending a request initiates a new session, which normally terminates with reception of the corresponding response. Sessions can terminate abnormally, e.g. upon a timeout. The request-response style demands blocking or asynchronous interface on the sender side since it should wait for and handle the eventual response or error. This provides a context for response messages linking them to the corresponding requests. However, the communication layer treats each individual session independently. More complex patterns of interaction have to be split into a number of one-shot request-response sessions. Multiple sessions may be initiated concurrently, and the communication layer needs to keep track of those one-shot sessions starting, running, and finishing concurrently.</p>
<p>The <em>session-based</em> style of communication is connection-oriented and supports <em>stateful</em> interaction between nodes. Communication sessions are established between individual nodes and represent reliable, ordered, bidirectional message streams. This provides a context for the messages being exchanged between nodes and implies blocking or asynchronous interface. Thanks to reliable and ordered delivery, the context establishes causal relationship between individual messages. Relying on those assumptions can greatly simplify the protocol implementation while taking advantage of the guarantees commonly provided by stream-based transport layers. This style of communication is quite generic and can express many different patterns of interaction. Combined with built-in flow control (backpressure), it is particularly suited for implementing <em>consumer-driven</em> communication. On the other hand, session-based communication cannot directly express multi-/broadcasting primitives and can induce additional latency in certain patterns of interaction. Though higher-level communication mechanisms built on top of session-based communication can implement multi-/broadcasting, whereas using <a href="https://en.wikipedia.org/wiki/Protocol_pipelining" target="_blank" rel="noopener noreferrer">pipelining</a> techniques can help to hide latency and achieve good performance.</p>
<p>The <em>gossip-style</em> communication designates probabilistic broadcasting in a relay network of nodes. It resembles the best-effort broadcasting in the fire-and-forget message delivery style. The key difference is that data in the gossip-style communication can propagate from one node to another in multiple hops rather than being received directly from the source node. This makes it suitable for sparsely connected networks. Therefore, gossip communication can scale well in large networks. It can provide, with high probability, eventual delivery of bounded amount of data under normal network conditions. This style of communication implies a publish-subscribe interface. Similar to the fire-and-forget message delivery, the interface is largely stateless and can be non-blocking. Under the hood, it is often implemented using the advertise-request-response pattern of communication: nodes advertise available pieces of data to their neighbors and exchange with them the missing parts following the request-response pattern. Efficient gossip implementations require adaptive network topology and advanced data dissemination techniques, which can make them fairly complicated.</p>
<p>An interesting example of using the gossip-style communication is artifact pools in the Internet Computer blockchain. Artifact pools in ICP are structured collections of artifacts, generic pieces of data produced by the local replica or received from other nodes. The gossip layer is responsible for synchronizing artifact pools between nodes. Nodes communicate with each other through the artifact pools by adding/removing/moving artifacts to/from/between pool sections. Higher-level code is responsible for artifact validation; it also determines retention and prioritization policies.</p>
<p>It is easy to notice that some styles of communication can be implemented in terms of others. So the request-response style is a reduced from of the session-based communication, which is more generic and expressive. Both can be implemented relying on the fire-and-forget delivery and using some message retransmission and acknowledgement protocol. Or conversely, the fire-and-forget message delivery can be implemented on top of a reliable session-based communication using bounded lossy message queues. Similarly, gossip mechanisms can be implemented using any of the other styles of communication; though the implementations may differ in complexity.</p>
<p>Different styles of communication have different properties that can significantly influence the shape of code built around them. Some of them are strictly more expressive than others, but do not necessarily reduce to an equivalent, because less expressive mechanisms may have more efficient implementations. In order to avoid accidental complexity when implementing distributed protocols, it is important to have a range of communication mechanisms with aligned interfaces and clearly defined properties.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="internal-communication">Internal Communication<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#internal-communication" class="hash-link" aria-label="Direct link to Internal Communication" title="Direct link to Internal Communication">​</a></h4>
<p>Apart from interaction between nodes, there is also communication between concurrent tasks within the same node. This internal communication shares some similarity with communication between nodes. The main difference is in the communication medium: while different nodes communicate through unreliable and slow network, internal communication happens through fast and reliable shared memory. Some programming models and techniques make the similarity particularly prominent, e.g. the <a href="https://en.wikipedia.org/wiki/Actor_model" target="_blank" rel="noopener noreferrer">actor model</a>, <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes" target="_blank" rel="noopener noreferrer">communicating sequential processes</a> (CSP), <a href="https://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank" rel="noopener noreferrer">remote procedure calls</a> (RPC), etc.</p>
<p>Any piece of shared memory can act as a communication channel between internal components. Such a channel can be established by simply sharing a reference to the corresponding piece of memory. Internal messages do not need translation into/from a binary representation; they can be simply shared by reference. The request-response style of communication can be implemented as simple invocation of blocking or asynchronous procedures (functions); invoking non-blocking procedures (functions) without a return value corresponds to the fire-and-forget message delivery style. Obviously, such procedures need to be safe for concurrent invocation.</p>
<p>The session-based communication style can be implemented for internal communication using the constructs commonly known as <a href="https://en.wikipedia.org/wiki/Channel_(programming)" target="_blank" rel="noopener noreferrer"><em>channels</em></a> (e.g. <a href="https://go.dev/ref/spec#Channel_types" target="_blank" rel="noopener noreferrer">channels</a> in Go, <a href="https://docs.rs/tokio/latest/tokio/sync/index.html#message-passing" target="_blank" rel="noopener noreferrer">Tokio channels</a> in Rust) or concurrent <em>queues</em> (e.g. <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedBlockingQueue.html" target="_blank" rel="noopener noreferrer"><code>LinkedBlockingQueue</code></a> and other concurrent <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html" target="_blank" rel="noopener noreferrer">queues</a> in Java). Those constructs belong to fundamental mechanisms of <em>communication and coordination</em> between concurrent components. Channels can be <em>buffered</em> or <em>unbuffered</em> (i.e. not buffered). Buffered channels and queues can hold items being sent through them without blocking the sender. In contrast, sending to or receiving from an unbuffered channel acts as a rendezvous point: it synchronizes the sender and the receiver at the point of communication.</p>
<p>Buffered channels and queues that can hold more than a singe item may return items to a receiver in different order. FIFO is the most commonly used ordering policy, in which items are returned in the same order as they were inserted. LIFO is another option, in which the most recently inserted item is the one that is returned first. One can think of many other options such as priority queues etc. The preferred ordering policy would depend on the purpose of communication.</p>
<p>Buffered channels and queues can be <em>bounded</em> or <em>unbounded</em>. The bounded version imposes a hard limit on the amount of items that they can hold. Unbounded channels and queues usually provide a simple <em>non-blocking</em> interface for inserting new items. However, they require some additional mechanism to prevent accumulating indefinite amount of items, e.g. blocking ingress of external events when internal buffers grow above certain threshold or relying on time-based assumptions such as throttling the data flow or imposing expiration time on the items. Such mechanisms can make reasoning about the protocol implementation more complicated.</p>
<p>Bounded channels and queues usually provide blocking or asynchronous interface. They can also support non-blocking insertion of new items, but then they must discard some items when there is no more capacity left. There may be different eviction policies. The simplest one is to discard the item being inserted. Otherwise, the new item is inserted, but some of the buffered items must be discarded, e.g. the least recently inserted one. Similarly to the ordering policy, there may be many other options, and the choice depends on the purpose of communication.</p>
<p>It is also worth mentioning buffered channels with a single-item buffer. They can be convenient for communicating a single item from one concurrent component to another, e.g. sending a response message back to the requester. The <a href="https://docs.rs/tokio/latest/tokio/sync/oneshot/index.html" target="_blank" rel="noopener noreferrer"><code>oneshot</code></a> channel in Tokio is a good example of such channel type. <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" target="_blank" rel="noopener noreferrer"><code>CompletableFuture</code></a> in Java can also be considered a kind of single-item buffered channel, as well as synchronizing variables&nbsp;<a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Control-Concurrent-MVar.html" target="_blank" rel="noopener noreferrer"><code>MVar</code></a> and <a href="https://hackage.haskell.org/package/stm-2.5.2.1/docs/Control-Concurrent-STM-TMVar.html" target="_blank" rel="noopener noreferrer"><code>TMVar</code></a> in Haskell. Another interesting example of a single-item buffered channel is the <a href="https://docs.rs/tokio/latest/tokio/sync/watch/index.html" target="_blank" rel="noopener noreferrer"><code>watch</code></a> channel in Tokio: it always keeps the last value sent to it. The <code>watch</code> channel is useful for watching for changes to a value from multiple concurrent components. Transactional variables (<a href="https://hackage.haskell.org/package/stm-2.5.3.0/docs/Control-Concurrent-STM-TVar.html" target="_blank" rel="noopener noreferrer"><code>TVar</code></a>s) in Haskell are somewhat similar to watch channels since STM&nbsp;transactions can be suspended until one of the&nbsp;<a href="https://hackage.haskell.org/package/stm-2.5.2.1/docs/Control-Concurrent-STM-TVar.html" target="_blank" rel="noopener noreferrer"><code>TVar</code></a>s that it has read from has been updated.</p>
<p>Channels and queues often serve as fundamental constructs to implement <a href="https://en.wikipedia.org/wiki/Message_passing" target="_blank" rel="noopener noreferrer">message passing</a> between concurrent components. They can be used to implement various styles of internal communication and higher-level components. For example, implementations of components for communication between nodes often use channels and queues as internal message buffers.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" target="_blank" rel="noopener noreferrer">publish-subscribe</a> design pattern resembles the gossip style of communication. It can be implemented for internal communication as an event bus or broadcast channel. Same as channels and queues, it can be buffered or unbuffered, bounded or unbounded. Unless messages can be dropped, unbuffered and bounded buffered implementations only support non-blocking publishing/broadcasting of messages if no subscriber blocks.</p>
<p>Similar to communication between nodes, different mechanisms and styles of internal communication have different properties that can significantly influence the shape of code. Therefore, it is equally important to have a range of internal communication mechanisms with aligned interfaces and clearly defined properties. The similarity between mechanisms for internal communication and communication between nodes provides an interesting perspective and can help to come up with better abstractions for communication.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="resilience">Resilience<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#resilience" class="hash-link" aria-label="Direct link to Resilience" title="Direct link to Resilience">​</a></h3>
<p><em>Fault-tolerant</em> distributed systems are meant to tolerate (within limits) faults of individual nodes due to crashes, network partitioning, malfunctioning, or even malicious behavior. Crash fault tolerant (CFT) systems, e.g. Apache Kafka and Apache Zookeeper, are relatively simple since they can only withstand node crashes and network partitioning. Byzantine fault tolerant (BFT) systems, e.g. public blockchains, are designed to withstand arbitrary (including malicious) behavior of a fraction of nodes and thus are significantly more complicated. There are two sides of the issue: preventing faulty or malicious nodes from compromising the whole system and recovering failed nodes to rejoin the system.</p>
<p>Theoretically, fault-tolerant distributed protocols are designed so that they guarantee their safely and liveness properties despite the presence of faulty nodes in the system, provided that certain assumptions hold. In practice, those guarantees are only provided if the implementation ensures that the required assumptions actually hold. This is particularly challenging in BFT systems meant to operate in adversarial environments. Nodes in such systems can be subjects to various attacks, such as denial-of-service (DoS) attacks through resource exhaustion. <em>Fairness</em> between peers is another concern since it may also impact resilience.</p>
<p>To mitigate those risks, many implementations maintain <em>reputation</em> metrics for remote peers and apply <em>rate-limiting</em> or <em>throttling</em> techniques. Peer reputation is based on the observable behavior of the peer, such as protocol violations, timeouts, and performance. Nodes normally disconnect from remote peers whose reputation drops below a certain threshold, as well as reject inbound connections from those peers. Conversely, peers with higher reputation may be preferred for communication in sparsely connected systems.</p>
<p>In its threat-aware design approach, Cardano emphasizes <em>detecting protocol violations&nbsp;as early as possible</em> in the operational cycle where the data is available but&nbsp;the least resources have been expended&nbsp;to process the received data<sup><a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#user-content-fn-threat-aware-approach-d8d72b" id="user-content-fnref-threat-aware-approach-d8d72b" data-footnote-ref="true" aria-describedby="footnote-label">5</a></sup>. For instance, block and transaction relaying is&nbsp;interleaved&nbsp;with validation to avoid circulating invalid data in the system. This approach works well with <em>stateful</em> <em>consumer-driven</em> communication between nodes: Inbound messages must be well-formed syntactically and semantically valid&nbsp;in the context&nbsp;of information previously received from the peer node.</p>
<p>In order to allow failed nodes to efficiently restore and safely rejoin the system, some parts of the protocol state can be persisted in a stable storage. This is usually implemented as a <a href="https://en.wikipedia.org/wiki/Write-ahead_logging" target="_blank" rel="noopener noreferrer">write-ahead log</a> (WAL), an append-only&nbsp;stable storage used for crash recovery. Certain events are first recorded in the log before the corresponding actions are taken, e.g. before sending messages to other nodes. This allows the node to restore and continue participating in the protocol from where it stopped, without violating the protocol. Persistence mechanisms are also required to support recovery from a massive system crash, i.e. to provide the <a href="https://en.wikipedia.org/wiki/Durability_(database_systems)" target="_blank" rel="noopener noreferrer">durability</a> property.</p>
<p>Early detection of protocol violations is advantageous, and the implementation structure should allow that. There should be a clear path for propagating information about detected protocol violations and other anomalies to adjust peer reputation metrics and take appropriate measures. Persistence mechanisms, such as write-ahead logging, are required for durability, as well as for safe and efficient node recovery.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="optimization">Optimization<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#optimization" class="hash-link" aria-label="Direct link to Optimization" title="Direct link to Optimization">​</a></h3>
<p>Practical distributed systems require not only reliability but also efficiency. Simplistic designs and implementations unfortunately tend to exhibit poor performance, whereas we would like that our systems scale well and provide decent <em>throughput</em> and <em>latency</em>. Improving those characteristics demands optimization at protocol and implementation levels. Great effort has been put into optimizing distributed protocols during decades of active research. This gave rise to a range of elaborate protocols attempting to achieve ever higher performance. On the implementation level, there also exists a variety of technical means for increasing efficiency. Optimizations, however, often add more complexity and make protocols harder to reason about and implement.</p>
<p>Protocol-level optimizations may involve using more complex communication patterns and topologies. Protocol phase <em>pipelining</em>, i.e. participating with a single message in multiple protocol phases at once, and <em>speculative execution</em> are common techniques to improve responsiveness. <em>Batching</em>, as well as advanced cryptography such as <a href="https://en.wikipedia.org/wiki/Threshold_cryptosystem" target="_blank" rel="noopener noreferrer">threshold signatures</a>, helps to reduce communication overhead. State-of-the-art protocols are often based on <em>advanced data structures</em>, such as <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" target="_blank" rel="noopener noreferrer">directed acyclic graphs</a> (DAGs). At the implementation level, <em>on-demand execution</em> and <em>caching</em> are often used to avoid performing unnecessary or duplicate operations.</p>
<p>Communication contributes significantly to the overall overhead in distributed systems and, therefore, is a clear target for optimization. Point-to-point <a href="https://en.wikipedia.org/wiki/Protocol_pipelining" target="_blank" rel="noopener noreferrer">protocol <em>pipelining</em></a>, i.e. continuous sending of requests without waiting for the corresponding responses, can greatly increase performance by hiding high network latency. Widely used transport protocols, such as TCP, tend to perform best under <em>steady data flow</em>. Moreover, keeping multiple network connections consumes additional system resources. Therefore, implementations commonly <em>multiplex</em> multiple logical communication streams through a single network connection. Minimizing <a href="https://en.wikipedia.org/wiki/Head-of-line_blocking" target="_blank" rel="noopener noreferrer"><em>head-of-line blocking</em></a> effects may require <em>flow control</em> mechanisms at the level of individual logical streams; large pieces of data should be transmitted through a multiplexed connection <em>in chunks</em>. Specific kinds of communication, e.g. state synchronization in blockchain systems, can benefit from dedicated, specialized communication mechanisms.</p>
<p>Interaction between concurrent components and across levels of abstraction is also subject to fine-tuning and optimization. <em>Prioritization</em> and flexible <em>policies</em> can help to maximize performance. For example, the system may perform better when certain concurrent tasks or communication paths have higher priority. Internal communication, as well as communication between nodes, may be optimized through prioritization and retention policies applied to individual messages or kinds of messages. This sort of optimization requires deep understanding of the protocol and its  inner workings.</p>
<p>Expensive low-level operations, such as spawning threads, blocking on locks, and copying data, can become a hidden cause of suboptimal performance. There are well-known techniques that can help to avoid unnecessary low-level overhead. For example, <a href="https://en.wikipedia.org/wiki/Thread_pool" target="_blank" rel="noopener noreferrer"><em>execution pools</em></a> avoid the overhead associated with creation and destruction of threads for executing short-lived concurrent tasks; <a href="https://en.wikipedia.org/wiki/Non-blocking_algorithm" target="_blank" rel="noopener noreferrer"><em>non-blocking algorithms</em></a> can improve performance by avoiding unnecessary suspension of thread execution; <a href="https://en.wikipedia.org/wiki/Zero-copy" target="_blank" rel="noopener noreferrer"><em>zero-copy</em></a> techniques focus on eliminating excessive copying of data.</p>
<p>Improving performance characteristics of distributed systems may require nontrivial changes in the underlying protocols and their implementations. The structure of the code should be flexible enough to support such changes. Some optimizations can be confined within boundaries of abstract components, whereas some may require crossing the borders of modularity. <em>Flexible</em> and <em>composable</em> primitives and interfaces <em>designed for optimization</em> would help to fully realize the potential of distributed systems in practice.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="correctness">Correctness<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#correctness" class="hash-link" aria-label="Direct link to Correctness" title="Direct link to Correctness">​</a></h2>
<p>Correctness is absolutely essential for implementation of distributed fault-tolerant protocols since they are critical for ensuring reliability of the whole system. <a href="https://en.wikipedia.org/wiki/Formal_verification" target="_blank" rel="noopener noreferrer"><em>Formal verification</em></a> methods allow confirming protocol correctness in terms of desired properties. Applying those methods requires that the protocol is described precisely with a <a href="https://en.wikipedia.org/wiki/Formal_specification" target="_blank" rel="noopener noreferrer"><em>formal specification</em></a>. Though the way protocols are actually implemented in code tends to be significantly different from the notation used in protocol specifications. This discrepancy is clearly a potential source of errors. There are different methods that can help to acquire higher confidence in correctness of the protocol implementation.</p>
<p>Testing is an established practice to examine correctness of software. Comprehensive testing of complex systems happens at different levels, and modularity of the code supports more effective testing by isolating functionalities, enabling independent unit testing, simplifying integration testing, and promoting code reuse. Some code bases include <em>dedicated interfaces</em> and <em>hooks</em> to facilitate testing; <a href="https://man.freebsd.org/cgi/man.cgi?query=fail" target="_blank" rel="noopener noreferrer"><em>fail points</em></a> is a technique that allows injecting errors and other behavior at runtime for testing purposes, which is used in Aptos and Sui. In Algorand, each&nbsp;component of the hierarchical state machine implementing the consensus protocol can perform <em>pre- and post-condition checks</em> to validate if it conforms to its contract. Most code bases perform diagnostic <em>logging</em> or <em>tracing</em> that can also be useful for testing, e.g. to check invariants in property-based testing.</p>
<p><em>Deterministic <a href="https://en.wikipedia.org/wiki/Discrete-event_simulation" target="_blank" rel="noopener noreferrer">discrete-event simulation</a></em> is a powerful technique that can be used for performing <em>randomized</em> but <em>reproducible</em> testing. For example, Sui, Apache Kafka, and Cardano employ this technique. It works by running the code within a special runtime that supports deterministic, randomized execution of concurrent code, as well as faster-than-real-time simulation of time delays. This technique can be used to run an entire network in a single process, with <em>simulated network</em> latency and packet loss. To ensure deterministic execution, the simulation approach usually requires that the code is generic over the sources of local time and randomness; it can also rely on code instrumentation techniques. The key advantage of this approach is that it allows running precisely the same code in the simulator for testing as in production.</p>
<p>Certain correctness properties of code can be ensured statically, i.e. at compile time. Those checks rely on the programming language's type system. Software engineers can take advantage of <em>type safety</em> features to implement components in a way that makes them <em>safe by construction</em>. For example, Cardano uses the&nbsp;<a href="https://github.com/input-output-hk/typed-protocols/tree/typed-protocols-0.1.0.5" target="_blank" rel="noopener noreferrer"><code>typed-protocols</code></a>&nbsp;package, a generic framework for implementing application-level protocols, which is based on a simple form of&nbsp;<a href="https://en.wikipedia.org/wiki/Session_type" target="_blank" rel="noopener noreferrer">session typing</a>.<sup><a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#user-content-fn-typed-protocols-talk-d8d72b" id="user-content-fnref-typed-protocols-talk-d8d72b" data-footnote-ref="true" aria-describedby="footnote-label">6</a></sup> Within this framework, protocols are described as state machines encoded into Haskell types. The allowed transitions between states correspond to messages exchanged between the peers, so the protocol state determines which messages are allowed to be sent or must be accepted when received, at type level. This simplifies protocol implementation, allows early detection of protocol violations, and makes the protocols themselves deadlock-free by construction. More advanced type-level programming techniques may allow achieving impressive levels of type safety; however, such code may be significantly harder to implement, understand, and maintain.</p>
<p>Ensuring correctness in distributed systems is a complex task. Protocols and their properties can be formally specified and verified. Expressing the protocol specification and its implementation using possibly similar notations could help to ensure equivalence between the two. Modular and generic structure of code, as well as using various testing support features within the code base, support more effective testing. Supporting deterministic discrete-event simulation is particularly powerful for reproducible randomized testing. Finally, type safety techniques like session types and typestates can eliminate certain kinds of programming errors at compile time.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="resource-utilization">Resource Utilization<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#resource-utilization" class="hash-link" aria-label="Direct link to Resource Utilization" title="Direct link to Resource Utilization">​</a></h2>
<p>Real computing systems are fundamentally bounded in the amount of available resources. Computers operate with limited computational power, memory, storage, and network bandwidth. Operating systems impose further limits on such system resources as threads, open network connections, file handles, etc. Practical systems are required to prevent <a href="https://en.wikipedia.org/wiki/Resource_leak" target="_blank" rel="noopener noreferrer">resource leaks</a>, as well as to ensure fair and efficient utilization of available resources.</p>
<p>Some resources, such as allocated memory, open file handles and network connections, spawned concurrent tasks and threads, may require explicit actions to release them properly when they are no longer needed. Failing to release resources promptly is known as a resource leak. It can cause <a href="https://en.wikipedia.org/wiki/Resource_starvation" target="_blank" rel="noopener noreferrer">resource starvation</a>, slowdowns, and instability in the system. Relying on explicit releasing of acquired resources is known to be error-prone. Automatically releasing resources based on <em>lifetimes</em> and <em>lexical scopes</em> is a more robust form of <a href="https://en.wikipedia.org/wiki/Resource_management_(computing)" target="_blank" rel="noopener noreferrer">resource management</a>. Sometimes the encompassing lexical scope's lifetime is longer than the resource's natural life cycle, e.g. when managing concurrent tasks, so that strict lexical scoping becomes inappropriate. In such cases, resources may be managed more explicitly within the scope, but with a fallback mechanism to track resources and ensure that any remaining resource gets released when leaving the scope.<sup><a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#user-content-fn-cardano-resource-registry-d8d72b" id="user-content-fnref-cardano-resource-registry-d8d72b" data-footnote-ref="true" aria-describedby="footnote-label">7</a></sup></p>
<p>Concurrency often makes resource management more challenging. First of all, concurrent tasks running in background is a kind of resource that needs to be released when no longer needed. Moreover, they can acquire other resources that should be released when the task is terminated, even in case of asynchronous cancellation. In simple cases, there is a limited number of long-running concurrent tasks, which are responsible for releasing the resources acquired by them, and their termination is synchronized with the main task; short-living jobs can run concurrently on execution pools that distribute those jobs among a number of long-running concurrent tasks. When more flexibility is desired, <a href="https://en.wikipedia.org/wiki/Structured_concurrency" target="_blank" rel="noopener noreferrer"><em>structured concurrency</em></a> can help managing concurrent code in a more organized and predictable manner by organizing concurrent tasks into a structured hierarchy with well-defined scopes and lifetimes.<sup><a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#user-content-fn-notes-on-structured-concurrency-d8d72b" id="user-content-fnref-notes-on-structured-concurrency-d8d72b" data-footnote-ref="true" aria-describedby="footnote-label">8</a></sup></p>
<p>Individual parts of a distributed system may operate at different pace. Moreover, for performance reasons, it is common to apply pipelining techniques when communicating with remote nodes, i.e. proceed without waiting for a response or acknowledgement form the remote node in order to hide network latency. Compensating for the delays and variability in throughput demands some kind of explicit or implicit buffering, e.g. buffered channels, send/receive queues, pending request trackers, out-of-context message buffers, etc. The amount of buffered state tends to grow under certain conditions, e.g. under heavy load or during network instability. Therefore, there should be some mechanisms to prevent <em>unbounded growth of state</em> without compromising liveness. That can be such mechanisms as backpressure, rate limiting, item expiration and eviction policies, etc.</p>
<p>In adversarial environments, potential DoS attacks through <em>resource exhaustion</em> is a major threat. An adversary may attempt to exhaust node's resources, such as network bandwidth, memory and computational capacity. In order to effectively mitigate such attacks, they should be prohibitively expensive for the attacker relative to the amount of resource consumed from honest participants. <em>Early detection of protocol violations</em> and <em>consumer-driven data flow</em>, as employed in Cardano, can reduce the amount of resources expended by the nodes under attack. It may also be useful to tack resource expenditure caused by processing messages from remote peers, as done in Avalanche, and apply <em>fair throttling</em> to communication channels.</p>
<p>Proper resource management is indispensable in long-running systems. It can be particularly challenging combined with concurrency. Reliable resource management approaches, e.g. based on lifetimes and lexical scopes, as well as structured concurrency, should be, when applicable, preferred to relying on explicit hand-coded releasing of acquired resources. Potential growth of state due to buffering requires mechanisms for ensuring bounded memory usage. Resource exhaustion attacks should be anticipated in adversarial environments and mitigated by minimizing their impact on honest nodes.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="maintainability">Maintainability<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#maintainability" class="hash-link" aria-label="Direct link to Maintainability" title="Direct link to Maintainability">​</a></h2>
<p>Maintenance of distributed systems is challenging. Those systems are usually long-running critical parts of infrastructure with high reliability requirements. They are complex systems consisting of multiple nodes, often operated independently by different entities. Publicly available deployments are also subject to malicious attacks. Thus effective maintenance of distributed systems demands comprehensive mechanisms and tools.</p>
<p>First of all, deploying distributed systems may require specific <em>bootstrapping</em> procedures in order to ensure a secure setup for the whole system. Different distributed protocols may have different requirements and rely on different assumptions for the <em>setup phase</em>.<sup><a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#user-content-fn-decentralized-setup-assumptions-d8d72b" id="user-content-fnref-decentralized-setup-assumptions-d8d72b" data-footnote-ref="true" aria-describedby="footnote-label">9</a></sup> Protocol implementations should be clear about the requirements and assumptions for their setup phase. Long-running, highly available distributed systems should be capable of <em>upgrading</em> individual nodes with newer versions of the protocol implementation without disrupting the whole system. This requires designing for <em>backward and forward compatibility</em>. Similarly, failed nodes should be able to <em>recover</em> and <em>rejoin</em> the system safely and efficiently. Moreover, it is also desired that the system is able to safely recover from a massive crash, i.e. provide <a href="https://en.wikipedia.org/wiki/Durability_(database_systems)" target="_blank" rel="noopener noreferrer">durability</a>. Therefore, the protocols should be designed and implemented with a clear recovery procedure.</p>
<p>Distributed system administrators need mechanisms and tools for monitoring individual nodes in order to analyze the system and promptly detect anomalies. Developers also need effective mechanisms for analyzing, diagnosing issues, and identifying bugs in protocol implementations. <em>Logging</em>, <em>tracing</em>, and collecting <em>metrics</em> are common <em>observability</em> techniques to allow monitoring and obtaining diagnostic information from the system; most of the explored code bases use these techniques. <a href="https://opentelemetry.io/" target="_blank" rel="noopener noreferrer">OpenTelemetry</a> and <a href="https://prometheus.io/" target="_blank" rel="noopener noreferrer">Prometheus</a> are popular open-source monitoring solutions, which are used in many of the explored code bases.</p>
<p>Diagnostic logging typically refers to emitting and recording chronological <em>textual</em> messages that capture important events happening during the execution of software. Messages in diagnostic logs are traditionally assigned a severity level that can be used to disable logging of messages below a certain severity level, e.g. debug messages. Log messages can support addition of structured data along with a formatted text message, e.g. key-value context fields. Logging can be organized hierarchically, reflecting the structure of components within the system. Messages in <em>hierarchical logging</em> are usually automatically enriched with context from higher-level components.</p>
<p>Tracing is somewhat similar to logging, but it is focused on capturing a detailed view of the flow of execution in the system. Tracing records are primarily <em>structured</em> rather than textual and reflect <em>causal relationships</em>. In particular, <em>distributed tracing</em> is tracking of events caused by processing individual logical operations, such as user requests or transactions, across different components of a distributed system. A distributed trace is associated with a single logical operation and consists of spans linked with causal relationships where each span represents a particular activity within the operation. Spans normally contain structured data describing the corresponding activity and timing information.</p>
<p>Metrics represent numeric measurements that describe the system's behavior over time. Metrics are typically collected and aggregated at regular intervals. They can include various types of information such as CPU and memory utilization, latency, error rates, throughput, queue lengths, etc. There are different kinds or metrics; the most widely used are counter, gauge, and histogram. A counter is a cumulative metric monotonically increasing over time; a gauge expresses the current value of some measurement; a histogram records sampled observations in a statistical representation.</p>
<p>Observability is a&nbsp;<a href="https://en.wikipedia.org/wiki/Cross-cutting_concern" target="_blank" rel="noopener noreferrer" title="Cross-cutting concern">cross-cutting concern</a>. Most implementations define abstract interfaces for logging, tracing, and capturing metrics and require them as dependency across components; some use code instrumentation techniques. Cardano uses an interesting approach to implement observability features, called <em>contravariant tracing</em>, in which domain-specific values are provided to domain-agnostic processors. The <a href="https://en.wikipedia.org/wiki/Functor#Covariance_and_contravariance" target="_blank" rel="noopener noreferrer">contravariance</a> property allows domain-agnostic tracers to be adapted and stand in where a domain-specific tracer is required. This discourages using textual encoding for diagnostic logging/tracing in favor of dedicated domain-specific event types. Contravariant tracing can also be used to collect metrics.</p>
<p>Detailed logging and tracing can add significant overhead. When logging a large amount of diagnostic data is expensive, logging can be <em>sampled</em>, producing only a subset of the total messages based on a predetermined sampling rate or criteria. The contravariant tracing incurs zero runtime cost if the program is compiled with tracing disabled; this is possible even when dealing with a tracer which ignores only certain types of events.</p>
<p>Fault-tolerant distributed protocols should be designed and implemented with clear bootstrapping, upgrading, and recovery procedures. Note that upgradability relies on backward and forward compatibility of the implementation. It is also worth considering the durability feature, i.e. the ability to safely recover the system from a massive crash. There should be seamless support for usual observability and diagnostic mechanisms.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="flexibility">Flexibility<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#flexibility" class="hash-link" aria-label="Direct link to Flexibility" title="Direct link to Flexibility">​</a></h2>
<p>Flexible software is able to adapt to changing requirements without having to undergo extensive restructuring. Flexibility is crucial for <em>adoption</em>, <em>reuse</em>, and <em>evolution</em> of code. Each explicit or implicit <em>assumption</em> or <em>requirement</em> imposed on how the code can be used is an additional <em>constraint</em> reducing flexibility. The explored code bases were primarily meant to implement particular protocols or serve specific purposes rather than to address fundamental needs for implementing distributed systems in general. This is a common approach to building software, but it tends to result in rather limited flexibility of the code.</p>
<p>In general, highly <em>modular</em> and <em>composable</em> code is also more flexible. Clear <a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="noopener noreferrer"><em>separation of concerns</em></a> through abstract interfaces and <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" target="_blank" rel="noopener noreferrer">dependency inversion</a> contributes to flexibility by enabling interchangeable components, as well as facilitating easier code modifications and extensions. Flexibility can also be enhanced with <em>generic</em> and <em>configurable</em> components. <a href="https://en.wikipedia.org/wiki/Generic_programming" target="_blank" rel="noopener noreferrer"><em>Generic programming</em></a> techniques, such as&nbsp;<a href="https://en.wikipedia.org/wiki/Parametric_polymorphism" target="_blank" rel="noopener noreferrer" title="Parametric polymorphism">parametric polymorphism</a>, encourage the development of more generic and adaptable components that can be used in different contexts without modification.</p>
<p>The ability to seamlessly integrate into larger systems is another aspect of flexibility required for adoption and reuse of protocol implementations. Since larger systems may opt for different programming languages and runtime environments, it is important to support interfacing with other languages and impose minimal runtime requirements. Rust is particularly suitable to implement robust software components for integrating into other languages and environments due to its rich language features, zero-cost abstractions, predictable performance, safe memory management without a garbage collector, and the ability to use custom concurrency runtimes.</p>
<p>Designing for flexibility promotes adoption, reuse, and evolution of code. Following this approach should be a deliberate choice from the beginning. Avoiding strong constraints, assumptions, and requirements, aiming at modularity and composability with generic and configurable components make for greater flexibility.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusions">Conclusions<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#conclusions" class="hash-link" aria-label="Direct link to Conclusions" title="Direct link to Conclusions">​</a></h2>
<p>I learned a lot while exploring those 14 code bases. I have acquired a much deeper understanding of what is important for a practical distributed protocol implementation and what are the typical challenges there. I have seen different approaches in use and discovered some interesting ideas and techniques scattered around. Though I find the ways distributed protocols are implemented quite unsatisfactory. Even for an engineer experienced in implementing this kind of protocols, most of the the code bases were fairly hard to comprehend and follow. I can imagine how much effort it took and how painful was it to first make them work, as well as to improve them later.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="status-quo">Status Quo<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#status-quo" class="hash-link" aria-label="Direct link to Status Quo" title="Direct link to Status Quo">​</a></h3>
<p>Most of the time, it was rather hard to follow the main protocol, its causal dependencies and logical connections in the code that was presumably structured focusing on the operational aspects, fragmented, entangled, and cluttered. Structuring the protocol implementation directly around simplistic communication mechanisms foregoing reliable and ordered delivery guarantees provided by the transport layers, expressing concurrency and synchronization explicitly in terms of low-level mechanisms based on shared mutable memory and lock-based primitives or attempting to evade concurrency in favor of sequential state machines, all seem to cause fragmentation of the protocol logic across the code base, shift the focus towards operational technicalities, and incur cluttering of the code with boilerplate and hand-coded flow control, context switching, resource management, etc. Invasive ad hoc optimizations, patches, and cross-cutting concerns also contribute to muddling the code. Often insufficient modularity, unclear structure, excessive coupling, and abundance of mutable state complicate the matter further. Using sophisticated techniques and lack of inline documentation present additional obstacles for understanding.</p>
<p>It seems barely possible to fully convince oneself that the majority of the implementations actually correspond closely to the original protocol and guarantee the claimed properties under unfavorable conditions. The way the protocols are expressed in code does not appear anything like formal specification. The ever-present possibility of such subtle issues as race conditions, deadlocks, resource starvation, and, in some languages, data races manifesting themselves in such complicated code bases does not add more confidence. Unconstrained nondeterminism and abundance of non-local operations result in state space explosion, making rigorous test-based verification infeasible. Only a few of the implementations support reproducible testing with deterministic discrete-event simulation of unmodified code.</p>
<p>It also seems unclear how many of the implementations would behave under certain high load conditions, e.g. under a denial-of-service attack. Protocol violations are not always optimally detected at early stages of processing incoming data; many implementations lack mechanisms for propagating information about detected anomalies towards lower communication layers in order to restrict communication with offending nodes. The majority of the implementations employ the push style of communication and forgo flow control mechanisms of transport layers, so individual remote nodes can potentially send arbitrary amounts of data that the receiving node has to deal with in time. Uncomfortably often there are unbounded buffers and queues with unclear mechanisms that could control growth of state. Unreliable explicit hand-coded resource management could cause resource leaks, including concurrent tasks dangling in background.</p>
<p>In terms of observability, most of the protocol implementations rely on simple logging with context fields and collect various metrics. However, this may not provide enough details and context for effective debugging and analysis of the protocol execution.</p>
<p>The explored code bases are quite specific to particular protocols, execution environments, and use cases. Modularity there is rather coarse and most of the components are not meant to be reused or recombined; tight coupling is also not rare. This harms adaptability and reusability of the code, making it inflexible.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="we-can-do-better">We Can Do Better<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#we-can-do-better" class="hash-link" aria-label="Direct link to We Can Do Better" title="Direct link to We Can Do Better">​</a></h3>
<p>I think we can do much better. I think we should not waste our efforts reinventing the wheel over and over again and repeating mistakes. Builders better focus on implementing the functionality specific to their solutions without having to figure out how to approach implementing the tricky but critically important distributed protocols. There should be a framework that solves the problem of implementing distributed protocols once and for all, a framework reach with easy-to-use, reliable primitives and components that can be taken as is or mixed and matched as needed, a framework that guides towards robust and understandable code, a framework that supports analyzing, monitoring, testing, and debugging protocol implementations, a framework that is reasonably efficient and can be easily integrated into various environments.</p>
<p>The framework should guide away from incidental, non-essential complexity and allow expressing protocol implementations in clear and understandable code. Protocol implementations should be structured primarily focusing on functional and logical aspects with clear separation of concerns, operational technicalities and sophisticated techniques possibly hidden behind simple and clearly defined abstractions. Fine modularity of reasonably small and simple components expressed in more declarative notation with reduced number of non-local operations should facilitate local reasoning. Components should have minimal internal state, as well as clearly defined requirements, properties, and external dependencies.</p>
<p>Concurrency requires special attention since it is unavoidable, tricky, and can add a great deal of complexity, whereas designing for concurrency can be actually advantageous in terms of code structure and modularity. Working with concurrency should be possibly safe, easy, and efficient. Low-level concurrency mechanisms, such as OS threads, lock-based synchronization primitives, and shared mutable memory, should only be used for implementing the internals of higher-level, safer, and easier-to-use concurrency mechanisms, such as concurrency runtimes. Expressing concurrent parts of the protocol in code should feel as natural as expressing sequential ones. This can be achieved with syntactical means, abstractions, and a concurrency model that recognizes any causally independent operations as potentially concurrent.</p>
<p>Since communication interfaces can greatly affect the structure of code built around them, we need a range of communication mechanisms with aligned interfaces and clearly defined properties. There should be different levels of abstractions for communication. Higher levels should take advantage of the properties already guaranteed by lower-level layers, such as reliable, ordered communication channels with flow control provided by commonly used transport layers. Expressing communication in stateful sessions can help to express causal relationship between individual messages and greatly simplify protocol implementations. Similarity between internal and external communication can suggest better abstractions.</p>
<p>Flexibility is extremely important to make the framework applicable to an open-ended space of use cases. Therefore, we should by all means avoid strong constraints, assumptions, and requirements. The framework should support integration with different programming languages and runtime environments. Its components should be generic and configurable. It should also support backward and forward compatibility. Composability is critical for ensuring great adaptability, reusability, and evolvability. It requires unified means of abstraction and combination. Generic programming techniques, such as parametric polymorphism, can be used to make components generic; functional and asynchronous programming techniques can be great sources of ideas for enhancing composability, particularly with concurrency.</p>
<p>Correctness of distributed protocol implementations should be verifiable, in terms of both safety and liveness properties. Formal verification methods are able to provide rigorous assurance about correctness of protocols and their implementations. However, since formal verification involves exhaustively analyzing all possible states of a system, it may become infeasible for large and complex components. Fine modularity, components amenable to local reasoning, as well as reducing the number of non-local and nondeterministic operations, can help making formal verification more tractable. In order to maintain equivalence between a formally verified protocol specification and its implementation in code, the implementation should be expressed possibly close to the formal specification, preferably using an identical notation. Type safely techniques, such as ownership, typestates, session types, linear and uniqueness types, can greatly help to ensure correctness of the code by making it virtually safe by construction in terms of certain properties. Hybrid approaches combining formal verification with other testing methods can be used to achieve decently high assurance about correctness where purely formal methods become infeasible. Deterministic discrete-event simulation of unmodified code is a particularly powerful technique to complement other verification methods with randomized, reproducible testing. Confining nondeterministic aspects behind abstract interfaces in code and being able to control nondeterminism during simulation is the key for enabling reproducible testing.</p>
<p>Distributed protocols and their implementations should provide strong guarantees even under unfavorable conditions, especially those supposed to be deployed in adversarial environments. The framework should employ a reliable approach for resource management in concurrent code, e.g. based on lifetimes and lexical scopes, structured concurrency. There should be mechanisms for flow control preventing unlimited growth of state and ensuring bounded memory usage. The framework should emphasize threat-aware design. Potential impact of resource exhaustion (DoS) attacks should be minimized with early detection of protocol violations and propagating information about detected anomalies for maintaining peer reputation metrics and taking appropriate measures. For that reason, consumer-driven patterns of communication should be preferred. There should also be mechanisms for safe and efficient recovery of failed nodes from persistent storage. Supporting durability, i.e. safe recovery after a massive system crash, is also desirable.</p>
<p>Protocols and their implementations should be clear about bootstrapping and recovery requirements and procedures. Upgradability requires backward and forward compatibility. There should be seamless support for usual observability and diagnostic mechanisms, such as logging, tracing, and collecting metrics. It may also be useful to provide mechanisms for tracking resource expenditure caused by processing incoming data. In place of simple logging with context fields, it seems advantageous supporting structured distributed tracing using domain-specific trace event types. This kind of tracing could also be suitable for collecting metrics. It is important to minimize incurred overhead when tracing is disabled. Code instrumentation can help to avoid cluttering code with tracing boilerplate.</p>
<p>The framework should provide good performance and support various optimizations, such as speculative and on-demand execution, caching, flexible prioritization policies. To support protocol-level optimizations, the framework should allow expressing complex communication patterns. The communication layer should prevent such undesired effects as head-of-line blocking, optimize data flow and take advantage of the properties provided by the transport layers. Lightweight user threads and non-blocking algorithms allow achieving high concurrency without compromising efficiency. Zero-copy techniques can be used to eliminate unnecessary copying of data.</p>
<p>So we need a structured, yet flexible enough, approach guiding away from incidental complexity towards understandability, fine modularity, and composability. The framework's components should be generic and configurable, allowing local reasoning about the implementation. Expressing concurrency and communication abstractions should be safe and easy, structured and composable. We should be serious about correctness and resilience against unfavorable conditions. The framework should also cater for maintenance needs, provide great observability and diagnostic mechanisms. It should deliver decent performance and allow for various optimizations.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="next-steps">Next Steps<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#next-steps" class="hash-link" aria-label="Direct link to Next Steps" title="Direct link to Next Steps">​</a></h2>
<p>Having explored those implementations of distributed protocol, now it became more clear to me what is worth focusing on while developing the Replica_IO framework. I define the following key areas of focus:</p>
<ul>
<li><em>simplicity</em>: making protocol implementations well structured and understandable;</li>
<li><em>flexibility</em>: keeping the framework adaptable, widely applicable, and evolvable;</li>
<li><em>reliability</em>: ensuring that protocol correctness is verifiable and the implementation is resilient;</li>
<li><em>efficiency</em>: allowing for various optimizations and delivering good performance;</li>
<li><em>maintainability</em>: catering for maintenance needs and providing great diagnostic mechanisms.</li>
</ul>
<p>Achieving all of that at once is obviously not realistic. Therefore, the primary focus will be initially put on simplicity, flexibility, and reliability, but without neglecting the remaining aspects. Of particular interest are the matters of structure and notation supporting composability in concurrency and communication mechanisms, as well as controlling nondeterminism.</p>
<p>Exploring distributed protocol implementations was the first phase of the initial state-of-the-art exploration. The next step is to select and examine some existing frameworks for developing distributed protocols in order to find out how they attempt to approach the problem and, perhaps, also discover some interesting techniques or ideas employed there. Then there are some potentially related concepts, approaches, and techniques worth looking into. The exploration tasks are tracked in the scope of <a href="https://github.com/replica-io/replica-io/issues/7" target="_blank" rel="noopener noreferrer">this issue</a> on GitHub.</p>
<p>Once the initial exploratory stage is over, it will be time to come up with key ideas concerning core principles that will guide the process of designing and implementing generic components within the framework (milestone <a href="https://github.com/replica-io/replica-io/milestone/1" target="_blank" rel="noopener noreferrer">M0.1</a>). Then those ideas will be developed into clearly formulated concepts (milestone&nbsp;<a href="https://github.com/replica-io/replica-io/milestone/2" target="_blank" rel="noopener noreferrer">M0.2</a>), their feasibility will be verified with code (milestone&nbsp;<a href="https://github.com/replica-io/replica-io/milestone/3" target="_blank" rel="noopener noreferrer">M0.3</a>). After that, prototype, MVP, and production versions of the framework will be developed and released (milestones &nbsp;<a href="https://github.com/replica-io/replica-io/milestone/4" target="_blank" rel="noopener noreferrer">M1</a>, &nbsp;<a href="https://github.com/replica-io/replica-io/milestone/5" target="_blank" rel="noopener noreferrer">M2</a>, and &nbsp;<a href="https://github.com/replica-io/replica-io/milestone/6" target="_blank" rel="noopener noreferrer">M3</a>).</p>
<p>It does not mean at all that exploration, ideation, and prototyping will not take place at later stages; the milestones simply define the framework's general level of maturity. The framework will continuously evolve and expand and at some point become a de facto standard for implementing critical fault-tolerant systems providing a growing collection of easy-to-use reliable and efficient distributed replication mechanisms.</p>
<!-- -->
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37">❤️</span>Supporting</div><div class="admonitionContent_BuS1">If you like the project and find it valuable, please <a href="https://github.com/sponsors/replica-io">support</a> its further development! 🙏</div></div>
<!-- -->
<section data-footnotes="true" class="footnotes"><h2 class="anchor anchorWithStickyNavbar_LWe7 sr-only" id="footnote-label">Footnotes<a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#footnote-label" class="hash-link" aria-label="Direct link to Footnotes" title="Direct link to Footnotes">​</a></h2>
<ol>
<li id="user-content-fn-other-impl-d8d72b">
<p>If you know of some other implementation that I should have absolutely looked into for some reason, please let me know. <a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#user-content-fnref-other-impl-d8d72b" data-footnote-backref="" aria-label="Back to reference 1" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-thinking-complexity-d8d72b">
<p>Actually, incidental complexity can start creeping in even earlier, into the way we <em>think</em> about distributed systems, but let's not go into this here. <a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#user-content-fnref-thinking-complexity-d8d72b" data-footnote-backref="" aria-label="Back to reference 2" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-tendermint-liveness-fix-d8d72b">
<p>Zarko Milosevic, CTO at Informal Systems, <a href="https://www.youtube.com/watch?v=c4BQ7v-CQfk&amp;t=296s" target="_blank" rel="noopener noreferrer">tells</a> in his invited talk at <a href="https://research.protocol.ai/sites/consensusday23/" target="_blank" rel="noopener noreferrer">ConsensusDays&nbsp;23</a> how a small protocol change addressing a major issue resulted in months of implementation work on the Tendermint code base. <a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#user-content-fnref-tendermint-liveness-fix-d8d72b" data-footnote-backref="" aria-label="Back to reference 3" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-modular-concurrency-with-stm-d8d72b">
<p>In his talk "<a href="https://www.youtube.com/watch?v=qlAKyivFxGQ" target="_blank" rel="noopener noreferrer">Using STM for Modular Concurrency</a>", Duncan Coutts expands on the approach to concurrency employed by Cardano. <a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#user-content-fnref-modular-concurrency-with-stm-d8d72b" data-footnote-backref="" aria-label="Back to reference 4" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-threat-aware-approach-d8d72b">
<p>More about the threat-aware design approach in <a href="https://iohk.io/en/research/library/papers/introduction-to-the-design-of-the-data-diffusion-and-networking-for-cardano-shelley/" target="_blank" rel="noopener noreferrer">"Introduction to the design of the Data Diffusion and Networking for Cardano Shelley"</a>. <a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#user-content-fnref-threat-aware-approach-d8d72b" data-footnote-backref="" aria-label="Back to reference 5" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-typed-protocols-talk-d8d72b">
<p>The <code>typed-protocols</code> framework was presented in the talk "<a href="https://skillsmatter.com/skillscasts/14633-45-minute-talk-by-duncan-coutts" target="_blank" rel="noopener noreferrer">Well-Typed Communication Protocols</a>" by Duncan Coutts. <a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#user-content-fnref-typed-protocols-talk-d8d72b" data-footnote-backref="" aria-label="Back to reference 6" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-cardano-resource-registry-d8d72b">
<p><a href="https://github.com/input-output-hk/ouroboros-consensus/blob/release-ouroboros-consensus-0.8.0.0/ouroboros-consensus/src/ouroboros-consensus/Ouroboros/Consensus/Util/ResourceRegistry.hs#L80" target="_blank" rel="noopener noreferrer"><code>ResourceRegistry</code></a>&nbsp;used in Cardano is an example of a fallback mechanism based on lexical scoping for preventing resource leaks. <a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#user-content-fnref-cardano-resource-registry-d8d72b" data-footnote-backref="" aria-label="Back to reference 7" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-notes-on-structured-concurrency-d8d72b">
<p>Nathaniel J. Smith elaborates on structured concurrency in great detail in his blog post <a href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/" target="_blank" rel="noopener noreferrer">"Notes on structured concurrency, or: Go statement considered harmful"</a>. <a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#user-content-fnref-notes-on-structured-concurrency-d8d72b" data-footnote-backref="" aria-label="Back to reference 8" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-decentralized-setup-assumptions-d8d72b">
<p><a href="https://decentralizedthoughts.github.io/2019-07-19-setup-assumptions/" target="_blank" rel="noopener noreferrer">This post</a> discusses the setup phase in distributed systems. <a href="https://replica-io.dev/blog/2024/03/04/on-implementation-of-distributed-prtocols#user-content-fnref-decentralized-setup-assumptions-d8d72b" data-footnote-backref="" aria-label="Back to reference 9" class="data-footnote-backref">↩</a></p>
</li>
</ol>
</section>]]></content>
        <author>
            <name>Sergey Fedorov</name>
            <email>sergefdrv@replica-io.dev</email>
            <uri>https://github.com/sergefdrv</uri>
        </author>
        <category label="technical" term="technical"/>
        <category label="overview" term="overview"/>
        <category label="long" term="long"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[The Story Behind Replica_IO]]></title>
        <id>https://replica-io.dev/blog/2023/09/04/the-story-behind-replica_io</id>
        <link href="https://replica-io.dev/blog/2023/09/04/the-story-behind-replica_io"/>
        <updated>2023-09-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[The Story Behind Replica_IO - an open-source framework for building practical distributed replication mechanisms.]]></summary>
        <content type="html"><![CDATA[<p>This post tells how the Replica_IO project originated and explains the
motivation behind it.</p>
<!-- -->
<!-- -->
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="my-background">My Background<a href="https://replica-io.dev/blog/2023/09/04/the-story-behind-replica_io#my-background" class="hash-link" aria-label="Direct link to My Background" title="Direct link to My Background">​</a></h2>
<p>I'd like to start by tell you a bit about my professional background.
I'm a research engineer with quite some experience in software
engineering. I began working as a software engineer back in 2009.</p>
<p>First 7 years, I was mostly focused on developing low-level system
software: I worked with such things as Linux kernel, microcontrollers,
hardware emulation, and trusted execution. Back then, I particularly
enjoyed contributing to <a href="http://qemu.org/" target="_blank" rel="noopener noreferrer">Qemu</a>, a generic and
open-source machine emulator and virtualizer. My contribution included
enhancing emulation of the ARM platform and enabling multithreading
support in the generic binary translation engine</p>
<p>In 2016, I took a big leap and came into research and development in
the areas of blockchain, distributed and decentralized systems. Soon
enough, I became absolutely excited about this, and since then, I keep
expanding my knowledge and experience in that area, in particular,
designing and implementing distributed protocols. During that period,
apart from proprietary stuff, I worked on the following open-source
projects:</p>
<ul>
<li><a href="http://github.com/hyperledger-labs/minbft" target="_blank" rel="noopener noreferrer">MinBFT Hyperledger Lab</a> — an implementation of the MinBFT
consensus protocol as a pluggable component. I was the main author,
contributor, and maintainer of the project.</li>
<li><a href="http://github.com/filecoin-project/mir" target="_blank" rel="noopener noreferrer">Mir</a> — a framework for implementing, debugging, and analyzing
distributed protocols. My main contribution was implementation of
the checkpointing mechanism, protocol garbage collection, and
reproducible testing with simulated time.</li>
<li><a href="http://fil.space/#components" target="_blank" rel="noopener noreferrer">Interplanetary Consensus (IPC)</a> — a framework to enable
on-demand horizontal scalability of the Filecoin blockchain. My
main contribution was redesign and implementation of the atomic
cross-chain transaction execution protocol in Rust.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="implementing-distributed-protocols">Implementing Distributed Protocols<a href="https://replica-io.dev/blog/2023/09/04/the-story-behind-replica_io#implementing-distributed-protocols" class="hash-link" aria-label="Direct link to Implementing Distributed Protocols" title="Direct link to Implementing Distributed Protocols">​</a></h2>
<p>So much was I excited about distributed systems, but, after a while, I
started feeling like there's something fundamentally wrong in how we
usually design and implement them.</p>
<p>Distributed protocols are notoriously complex, and it took academia
significant effort to develop a solid theoretical foundation for them.
Due to inherent concurrency, the reasoning about distributed systems
is quite tricky, and there are lots of pitfalls where one gets trapped
pretty quickly, unless being extremely careful. Though, I find this
really fascinating because I particularly love digging deep and
thinking thoroughly.</p>
<p>However, the way distributed protocols are conventionally described on
paper makes it hardly possible to implement them correctly with
confidence; it's simply too far from the realities of software
engineering. Not only academic papers often neglect some details of
practical importance but also the language and notation used there,
they require nontrivial translation to the languages and patterns
commonly used in programming. Add there typical issues that come up
inevitably when programming concurrent systems, time pressure, and we
end up with a great mess that one can hardly comprehend and maintain.</p>
<p>Moreover, it seems like those engineers who get their hands dirty and
implement distributed protocols for practical use tend to jump in and
try applying whatever approach they were used to or that was implied
by the surrounding system. Although one can certainly learn a lot from
such experiments (and I'm doing that), it's generally waste of efforts
when one simply needs to get the thing reliably working. More than
that, since this kind of code is quite hard to get right, inevitable
mistakes creep into such implementations and lurk there unnoticed.
Even when some of those mistakes get revealed, individual projects are
usually too busy and too specific to keep following and effectively
learning from each other.</p>
<p>Having implemented a couple of distributed protocols myself, I find
this status quo deeply unsatisfactory, especially when it comes to
distributed replication mechanisms such as consensus protocols. After
all, they are supposed to ensure consistency and availability in such
critical computing systems as distributed coordination services,
distributed databases, and blockchain. There is an opinion that the
main obstacle to wider adoption of distributed, decentralized systems,
particularly those capable of tolerating arbitrary (Byzantine) faults,
is their requirement for additional resources and reduced performance.
While it's certainly true that high reliability doesn't come for free,
I think the concerns regarding complexity do actually matter a lot in
the end; it's simply hard to get it right.</p>
<p>I think decentralized Byzantine-fault tolerant mechanisms should
prevail in future computing systems and we can do a much better job
working towards that. I believe such complex problems can have neat
solutions, not only efficient, but also easy to use. Clearly,
discovering and developing such solutions does take quite some effort.
There must have been attempts to solve this problem, apparently not
very successful. But since I like to think of myself as someone
discovering smart solutions to hard problems, I'm not too scared; I'm
stubborn enough 😄</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="replica_io">Replica_IO<a href="https://replica-io.dev/blog/2023/09/04/the-story-behind-replica_io#replica_io" class="hash-link" aria-label="Direct link to Replica_IO" title="Direct link to Replica_IO">​</a></h2>
<p>So I was thinking about this for years, but never managed to find room
for seriously working on it. Suddenly, in February 2023, I was
affected by a lay-off in <a href="https://protocol.ai/" target="_blank" rel="noopener noreferrer">Protocol Labs</a> and had to
leave; by that time, I had worked with the company as a long-term
collaborator, a Research Engineer at the <a href="https://research.protocol.ai/groups/consensuslab/" target="_blank" rel="noopener noreferrer">ConsensusLab</a>
group, for almost a year. After a while, I realized that this is
actually a great chance to finally start working on what I was
dreaming of.</p>
<p>Initially, I thought I would just take a break and spend some time on
a hobby project. I already had a name for it — Replica_IO, which had
come to my mind a few months before, as I had been yet again thinking
about communication between replicas in a distributed replication
system. However, once I started asking myself about my real intention
behind this, I realized that it's much bigger than just playing with a
pet project: what I really want is to make a breakthrough in how
distributed systems are designed and implemented!</p>
<p>In March 2023, I decided to found the Replica_IO project and work on
it full time as an independent research engineer. Since I believe in
open source, open innovation and collaboration, I also wanted to make
it radically open and started developing it entirely in the open from
day one. I <a href="https://github.com/replica-io/replica-io/issues/2" target="_blank" rel="noopener noreferrer">described</a> the project's purpose, goals, and
approach, <a href="https://github.com/replica-io/replica-io/issues/3" target="_blank" rel="noopener noreferrer">created</a> its logo, <a href="https://github.com/replica-io/replica-io/issues/1" target="_blank" rel="noopener noreferrer">defined</a> the initial
roadmap, and started working on the <a href="https://github.com/replica-io/replica-io/milestone/1" target="_blank" rel="noopener noreferrer">first milestone</a>.</p>
<p>At the time of this writing, I'm <a href="https://github.com/replica-io/replica-io/issues/7" target="_blank" rel="noopener noreferrer">exploring</a> some relevant
state of the art, <a href="https://github.com/replica-io/replica-io/wiki/State-of-the-art-exploration" target="_blank" rel="noopener noreferrer">summarizing</a> the findings.
Approaching this in a systematic way lets me dive deeper into the
problem, form a more educated opinion, find some inspiration, and
ultimately come up with effective ideas for achieving the project's
key technical objectives.</p>
<p>I understand how ambitious the goals of this project are and that it
may take long time to get there, but I'm absolutely sure it is worth
the effort. I'm surprised how much attention the project has already
attracted and would like to see great experts from the relevant fields
become involved and help to make it real. I also count on getting enough
support for this initiative, and I'm grateful to those who have
already been helping 🙏</p>
<p>If you'd like to learn more about this project, please visit the
<a href="https://replica-io.dev/about">About</a> page and watch <a href="https://youtu.be/oJlryr6bMCo" target="_blank" rel="noopener noreferrer">this talk</a>.</p>]]></content>
        <author>
            <name>Sergey Fedorov</name>
            <email>sergefdrv@replica-io.dev</email>
            <uri>https://github.com/sergefdrv</uri>
        </author>
        <category label="introduction" term="introduction"/>
        <category label="announcement" term="announcement"/>
        <category label="story" term="story"/>
    </entry>
</feed>